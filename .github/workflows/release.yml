name: ðŸ·ï¸ Release and publish new version

on:
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}
  HUSKY: 0

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  bump-version:
    name: Bump and Compile
    runs-on: ubuntu-latest
    outputs:
      new_tags: ${{ steps.extract_tags.outputs.new_tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install ESPHome
        run: |
          npm run setup-esphome
          echo "$PWD/.venv/bin" >> $GITHUB_PATH

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm ci

      - name: CI Checks
        run: npm run ci-checks
      
      - name: Create new version
        id: version-step
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          
          npm run new-version

      - name: Extract Created Tags
        id: extract_tags
        run: |
          TAGS=$(git tag --points-at HEAD | jq -R -s -c 'split("\n")[:-1]')
          echo "Found tags: $TAGS"
          echo "new_tags=$TAGS" >> $GITHUB_OUTPUT

      - name: Compile artifacts
        if: ${{ steps.extract_tags.outputs.new_tags != '[]' && steps.extract_tags.outputs.new_tags != '' }}
        run: |
          TAGS='${{ steps.extract_tags.outputs.new_tags }}'
          for TAG in $(echo "$TAGS" | jq -r '.[]'); do
            echo "Compiling artifacts for tag: $TAG"

            # Extract package name from tag (e.g., @tierralive-firmware/sensasoil_v3-0@0.0.1 -> @tierralive-firmware/sensasoil_v3-0)
            PKG_NAME=${TAG%@*}

            # Find package location
            PKG_PATH=$(npm run --silent list-packages | jq -r --arg pkg "$PKG_NAME" '.[] | select(.name == $pkg) | .location')

            if [ -z "$PKG_PATH" ] || [ "$PKG_PATH" == "null" ]; then
                echo "Error: Package '$PKG_NAME' not found in the monorepo." >&2
                exit 1
            fi

            PKG_PRIVATE=$(npm run --silent list-packages | jq -r --arg pkg "$PKG_NAME" '.[] | select(.name == $pkg) | .private')
            # Skip if the package is private
            if [ "$PKG_PRIVATE" == "true" ]; then
                echo "Skipping private package '$PKG_NAME'."
                continue
            fi

            # Get the path after 'devices/' to use as DEVICE_CONF_PATH
            DEVICE_CONF_PATH=${PKG_PATH#*/devices/}  # e.g., sensasoil/v3-0

            # Compile the device firmware
            # Get the artifact base name for later use (use the stuff after the slash in the package name)
            ARTIFACT_BASE=${PKG_NAME#*/}  # e.g., sensasoil-v3-0
            npm run compile-device ${DEVICE_CONF_PATH} dist/${ARTIFACT_BASE}
          done

      - name: Upload artifacts
        if: ${{ steps.extract_tags.outputs.new_tags != '[]' && steps.extract_tags.outputs.new_tags != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: esphome-artifacts
          path: dist/*.bin*

  publish-assets:
    name: Publish Assets
    needs: bump-version
    # Only run if tags were actually created
    if: ${{ needs.bump-version.outputs.new_tags != '[]' && needs.bump-version.outputs.new_tags != '' }}
    runs-on: ubuntu-slim
    strategy:
      matrix:
        tag: ${{ fromJson(needs.bump-version.outputs.new_tags) }}
      fail-fast: false
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.tag }}
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: esphome-artifacts
          path: dist

      - name: Resolve artifact paths
        run: |
          TAG="${{ matrix.tag }}"
          ARTIFACT_BASE="${TAG#*/}"
          ARTIFACT_BASE="${ARTIFACT_BASE%@*}"
          echo "OUTPUT_OTA_FIRMWARE=dist/${ARTIFACT_BASE}.ota.bin" >> $GITHUB_ENV
          echo "OUTPUT_OTA_MD5=dist/${ARTIFACT_BASE}.ota.bin.md5" >> $GITHUB_ENV
          echo "OUTPUT_FACTORY_FIRMWARE=dist/${ARTIFACT_BASE}.factory.bin" >> $GITHUB_ENV
          echo "OUTPUT_FACTORY_MD5=dist/${ARTIFACT_BASE}.factory.bin.md5" >> $GITHUB_ENV
          VERSION_NAME="${TAG##*@}"
          PKG_NAME=${TAG%@*}
          LATEST_TAG="${PKG_NAME}@latest"
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV
          echo "${VERSION_NAME}" > ${ARTIFACT_BASE}.version.txt
          echo "VERSION_FILE=${ARTIFACT_BASE}.version.txt" >> $GITHUB_ENV

      - name: Upload to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ matrix.tag }}
          files: |
            ${{ env.OUTPUT_OTA_FIRMWARE }}
            ${{ env.OUTPUT_OTA_MD5 }}
            ${{ env.OUTPUT_FACTORY_FIRMWARE }}
            ${{ env.OUTPUT_FACTORY_MD5 }}
        env:
          generate_release_notes: true

      - name: Update latest tag
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          git tag -f "${LATEST_TAG}"
          git push -f origin "${LATEST_TAG}"

      - name: Upload to Latest Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.LATEST_TAG }}
          files: |
            ${{ env.OUTPUT_OTA_FIRMWARE }}
            ${{ env.OUTPUT_OTA_MD5 }}
            ${{ env.OUTPUT_FACTORY_FIRMWARE }}
            ${{ env.OUTPUT_FACTORY_MD5 }}
            ${{ env.VERSION_FILE }}
        env:
          generate_release_notes: true
