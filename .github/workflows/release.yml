name: ðŸ·ï¸ Release and publish new version

on:
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}
  HUSKY: 0

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-slim
    outputs:
      new_tags: ${{ steps.extract_tags.outputs.new_tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm ci

      - name: CI Checks
        run: npm run ci-checks
      
      - name: Create new version
        id: version-step
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          
          npm run new-version

      - name: Extract Created Tags
        id: extract_tags
        run: |
          TAGS=$(git tag --points-at HEAD | jq -R -s -c 'split("\n")[:-1]')
          echo "Found tags: $TAGS"
          echo "new_tags=$TAGS" >> $GITHUB_OUTPUT

  publish-assets:
    name: Publish Assets
    needs: bump-version
    # Only run if tags were actually created
    if: ${{ needs.bump-version.outputs.new_tags != '[]' && needs.bump-version.outputs.new_tags != '' }}
    runs-on: ubuntu-slim
    strategy:
      matrix:
        tag: ${{ fromJson(needs.bump-version.outputs.new_tags) }}
      fail-fast: false
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.tag }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm ci

      - name: Compile artifact
        id: artifacts
        run: |
          TAG="${{ matrix.tag }}"

          # Extract package name from tag (e.g., @tierralive-firmware/sensasoil_v3_0@0.0.1 -> @tierralive-firmware/sensasoil_v3_0)
          PKG_NAME=${TAG%@*}
          echo "Package Name: $PKG_NAME"

          # Find package location
          PKG_PATH=$(npm run --silent list-packages | jq -r --arg pkg "$PKG_NAME" '.[] | select(.name == $pkg) | .location')

          if [ -z "$PKG_PATH" ] || [ "$PKG_PATH" == "null" ]; then
              echo "Error: Package '$PKG_NAME' not found in the monorepo."
              exit 1
          fi

          PKG_PRIVATE=$(npm run --silent list-packages | jq -r --arg pkg "$PKG_NAME" '.[] | select(.name == $pkg) | .private')
          # Skip if the package is private
          if [ "$PKG_PRIVATE" == "true" ]; then
              echo "Skipping private package '$PKG_NAME'."
              exit 0
          fi

          echo "Found package path: $PKG_PATH"

          # Get the path after 'devices/' to use as DEVICE_CONF_PATH
          DEVICE_CONF_PATH=${PKG_PATH#*/devices/}  # e.g., sensasoil/v3_0

          # Compile the device firmware
          # Get the artifact base name for later use (use the stuff after the slash in the package name)
          ARTIFACT_BASE=${PKG_NAME#*/}  # e.g., sensasoil_v3_0
          npm run compile-device ${DEVICE_CONF_PATH} dist/${ARTIFACT_BASE}

          # Define assets for upload (.bin and .bin.md5)
          OUTPUT_FIRMWARE="dist/${ARTIFACT_BASE}.bin"
          OUTPUT_MD5="dist/${ARTIFACT_BASE}.bin.md5"

      - name: Upload to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ matrix.tag }}
          files: |
            ${{ steps.artifacts.outputs.OUTPUT_FIRMWARE }}
            ${{ steps.artifacts.outputs.OUTPUT_MD5 }}
        env:
          generate_release_notes: true
