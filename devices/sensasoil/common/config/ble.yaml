esp32_ble:
  id: ble_id
  enable_on_boot: False

esp32_ble_server:
  id: ble_server
  manufacturer: TierraLive
  model: SensaSoil_${HARDWARE_VERSION}
  # TODO: Maximum one client
  on_connect:
    # Update sensors
    - script.execute: refresh_sensors_script
    - lambda: |-
        ESP_LOGD("BLE", "Connection from %d", id);
    - lambda: ! id(last_ble_communication_timestamp) = millis();
  on_disconnect:
    - lambda: |-
        ESP_LOGD("BLE", "Disconnection from %d", id);
  services:
    - uuid: 0x180F
      advertise: false
      characteristics: 
        - uuid: 0x2A19
          id: ble_battery_level_char
          read: true
          notify: true
          value: !lambda |-
            return { static_cast<uint8_t>(std::round(id(battery_percentage).state)) };
        - uuid: 0x2BED
          id: ble_battery_status_char
          read: true
          notify: true
          value: !lambda |-
            // Flags field (8 bits)
            uint8_t flags = 0b00000010;
            // Power state field (16 bits)
            uint16_t power_state = 0b0000000000000000;
            // Battery present (bit 0)
            // Assume always 1 (we cannot check that)
            power_state |= 0b0000000000000001;
            // Wired external power source connected (bits 1-2)
            // Set to 10 (unknown) as we do not know if it is connected to a charger
            power_state |= (0b10 << 1);
            // Wireless external power source connected (bits 3-4)
            power_state |= (0b10 << 3);
            // Set to 10 (unknown) as we do not know if it is solar charging
            // Battery charge state (bits 5-6)
            if (id(is_battery_charging).state) {
              // Charging
              power_state |= (0b01 << 5);
            } else {
              // Discharging
              power_state |= (0b10 << 5);
            }
            // Battery charge level (bits 7-8)
            float bat_level = id(battery_percentage).state;
            if (bat_level <= 5.0) {
              // Critical
              power_state |= (0b11 << 7);
            } else if (bat_level <= 20.0) {
              // Low
              power_state |= (0b10 << 7);
            } else {
              // Good
              power_state |= (0b01 << 7);
            }
            // Display battery level too
            uint8_t battery_level_output = static_cast<uint8_t>(std::round(bat_level));
            return { flags, static_cast<uint8_t>(power_state & 0xFF), static_cast<uint8_t>((power_state >> 8) & 0xFF), battery_level_output };
    - uuid: ${CUSTOM_BLE_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${CUSTOM_BLE_INFO_UUID}
          read: true
          value: !lambda |-
            uint8_t mac[6];
            get_mac_address_raw(mac);
            return std::vector<uint8_t>(std::begin(mac), std::end(mac));
    - uuid: ${IMPROV_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${IMPROV_STATUS_UUID}
          id: improv_status_characteristic
          read: true
          notify: true
          value: !lambda return {id(improv_state)};
        - uuid: ${IMPROV_ERROR_UUID}
          id: improv_error_characteristic
          read: true
          notify: true
        - uuid: ${IMPROV_RPC_COMMAND_UUID}
          write: true
          on_write:
            then:
              # TODO: Add "INDENTIFY" capabilities
              - lambda: |-
                  ESP_LOGD("ExtendedImprov", "Characteristic received: %s from %d", std::string(x.begin(), x.end()).c_str(), id);
                  id(last_ble_communication_timestamp) = millis();
                  if (x.empty()) return;
                  id(improv_buffer).insert(id(improv_buffer).end(), x.begin(), x.end());
                  uint8_t length = id(improv_buffer)[1];
                  if (id(improv_buffer).size() - 3 == length) {
                    id(improv_error_characteristic)->set_value(improv::ERROR_NONE);
                    id(improv_error_characteristic)->notify();
                    improv::ImprovCommand command = improv::parse_improv_data(id(improv_buffer));
                    switch (command.command) {
                      case improv::BAD_CHECKSUM:
                        ESP_LOGW("ExtendedImprov", "Error decoding Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_INVALID_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                        break;
                      case improv::WIFI_SETTINGS: {
                        ESP_LOGD("ExtendedImprov", "Wi-Fi settings received");
                        if (id(improv_state) != improv::STATE_AUTHORIZED) {
                          ESP_LOGD("CustomImprov", "Settings received, but not authorized");
                          id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                          id(improv_error_characteristic)->notify();
                          id(improv_buffer).clear();
                          return;
                        }
                        id(improv_state) = improv::STATE_PROVISIONING;
                        id(improv_status_characteristic)->notify();
                        id(improv_wifi_configure)->execute(std::string(command.data[0].begin(), command.data[0].end()), std::string(command.data[1].begin(), command.data[1].end()));
                        id(improv_buffer).clear();
                        break;
                      }
                      case improv::CUSTOM: {
                        ESP_LOGD("ExtendedImprov", "Custom command received");
                        switch(command.data[0][0]) {
                          case ${E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID}:
                            if (id(improv_state) != improv::STATE_AUTHORIZED) {
                              ESP_LOGD("CustomImprov", "MQTT settings received, but not authorized");
                              id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                              id(improv_error_characteristic)->notify();
                              id(improv_buffer).clear();
                              return;
                            }
                            ESP_LOGD("ExtendedImprov", "MQTT settings received");
                            id(improv_state) = improv::STATE_PROVISIONING;
                            id(improv_status_characteristic)->notify();
                            id(improv_mqtt_configure)->execute(std::string(command.data[1].begin(), command.data[1].end()), bytebuffer::ByteBuffer::wrap(command.data[2]).get_uint16(), std::string(command.data[3].begin(), command.data[3].end()), std::string(command.data[4].begin(), command.data[4].end()));
                            break;
                          case ${E_IMPROV_FACTORY_RESET_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Factory reset received");
                            id(factory_reset_button).press();
                          case ${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of MQTT settings received");
                            id(improv_wifi_mqtt_show_config)->execute();
                            break;
                          case ${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of WiFi settings received");
                            id(improv_wifi_ble_show_config)->execute();
                            break;
                          default:
                            ESP_LOGW("ExtendedImprov", "Unknown Improv custom payload");
                            break;
                        }
                        break;
                      }
                      case improv::IDENTIFY:
                        id(improv_buffer).clear();
                        ESP_LOGW("ExtendedImprov", "IDENTIFY");
                        break;
                      default:
                        ESP_LOGW("ExtendedImprov", "Unknown Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_UNKNOWN_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                    }
                  } else if (id(improv_buffer).size() - 2 > length) {
                    ESP_LOGD("ExtendedImprov", "Too much data received or data malformed; resetting buffer...");
                    id(improv_buffer).clear();
                  } else {
                    ESP_LOGD("ExtendedImprov", "Waiting for split data packets...");
                  }
        - uuid: ${IMPROV_CAPABILITIES_UUID}
          read: true
          value:
            data: 0x00
            type: uint8_t
        - uuid: ${IMPROV_RPC_RESULT_UUID}
          id: improv_rpc_result
          read: true
          notify: true
