substitutions:
  # Improv BLE
  IMPROV_SERVICE_UUID: "00467768-6228-2272-4663-277478268000"
  IMPROV_STATUS_UUID: "00467768-6228-2272-4663-277478268001"
  IMPROV_ERROR_UUID: "00467768-6228-2272-4663-277478268002"
  IMPROV_RPC_COMMAND_UUID: "00467768-6228-2272-4663-277478268003"
  IMPROV_RPC_RESULT_UUID: "00467768-6228-2272-4663-277478268004"
  IMPROV_CAPABILITIES_UUID: "00467768-6228-2272-4663-277478268005"
  # ExtendedImprov commands
  E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID: "1"
  E_IMPROV_FACTORY_RESET_COMMAND_ID: "2"
  E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID: "3"
  E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID: "4"
  E_IMPROV_ENABLE_DIAGNOSTIC_COMMAND_ID: "5"
  E_IMPROV_MQTT_DISCOVERY_PREFIX_COMMAND_ID: "6"
  # Custom BLE
  CUSTOM_BLE_SERVICE_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80000"
  CUSTOM_BLE_INFO_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80001"
  # Internal setup states
  SETUP_STATE_INIT: "0"
  SETUP_STATE_WIFI_CONFIG: "1"
  SETUP_STATE_MQTT_CONFIG: "2"
  # Timeouts
  DELAY_BLE_SERVER_CLOSE_MS: "5 * 60 * 1000"

globals:
  # INTERNAL #
  - id: last_ble_communication_timestamp
    type: unsigned long
    restore_value: no
    initial_value: "0"
  - id: improv_state
    type: improv::State
    restore_value: no
  - id: device_setup_state
    type: uint8_t
    restore_value: no
    initial_value: ${SETUP_STATE_INIT}
  - id: temp_wifi_ssid
    type: std::string
    restore_value: no
  - id: temp_wifi_password
    type: std::string
    restore_value: no

esp32_ble:
  id: ble_id
  enable_on_boot: False
  max_connections: 1

# TODO: Check that improv RPC command flow works
esp32_ble_server:
  id: ble_server
  manufacturer: TierraLive
  model: SensaSoil_${HARDWARE_VERSION}
  # TODO: Enable when ESPHome supports it
  # max_clients: 1
  on_connect:
    - lambda: |-
        // Refresh sensors on BLE connection to have updated values
        id(refresh_sensors_script)->execute();
        id(last_ble_communication_timestamp) = millis();
  services:
    - uuid: 0x180F
      advertise: false
      characteristics: 
        - uuid: 0x2A19
          id: ble_battery_level_char
          read: true
          notify: true
          value: !lambda |-
            return { static_cast<uint8_t>(std::round(id(battery_level).state)) };
        - uuid: 0x2BED
          id: ble_battery_status_char
          read: true
          notify: true
          value: !lambda |-
            // Flags field (8 bits)
            uint8_t flags = 0b00000010;
            // Power state field (16 bits)
            uint16_t power_state = 0b0000000000000000;
            // Battery present (bit 0)
            // Assume always 1 (we cannot check that)
            power_state |= 0b0000000000000001;
            // Wired external power source connected (bits 1-2)
            // Set to 10 (unknown) as we do not know if it is connected to a charger
            power_state |= (0b10 << 1);
            // Wireless external power source connected (bits 3-4)
            power_state |= (0b10 << 3);
            // Set to 10 (unknown) as we do not know if it is solar charging
            // Battery charge state (bits 5-6)
            if (id(is_battery_charging).state) {
              // Charging
              power_state |= (0b01 << 5);
            } else {
              // Discharging
              power_state |= (0b10 << 5);
            }
            // Battery charge level (bits 7-8)
            float bat_level = id(battery_level).state;
            if (bat_level <= 5.0) {
              // Critical
              power_state |= (0b11 << 7);
            } else if (bat_level <= 20.0) {
              // Low
              power_state |= (0b10 << 7);
            } else {
              // Good
              power_state |= (0b01 << 7);
            }
            // Display battery level too
            uint8_t battery_level_output = static_cast<uint8_t>(std::round(bat_level));
            return { flags, static_cast<uint8_t>(power_state & 0xFF), static_cast<uint8_t>((power_state >> 8) & 0xFF), battery_level_output };
    - uuid: ${CUSTOM_BLE_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${CUSTOM_BLE_INFO_UUID}
          read: true
          value: !lambda |-
            uint8_t mac[6];
            get_mac_address_raw(mac);
            return std::vector<uint8_t>(std::begin(mac), std::end(mac));
    - uuid: ${IMPROV_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${IMPROV_STATUS_UUID}
          id: improv_status_characteristic
          read: true
          notify: true
          value: !lambda return {id(improv_state)};
        - uuid: ${IMPROV_ERROR_UUID}
          id: improv_error_characteristic
          read: true
          notify: true
        - uuid: ${IMPROV_RPC_COMMAND_UUID}
          write: true
          on_write:
            then:
              - lambda: |-
                  static std::vector<uint8_t> improv_buffer;
                  static std::function<void(const improv::Error&)> set_error_notify_and_clear = [](improv::Error error) {
                    id(improv_error_characteristic)->set_value(error);
                    id(improv_error_characteristic)->notify();
                    improv_buffer.clear();
                  };
                  static std::function<bool(const std::vector<std::vector<uint8_t>>&, size_t)> ensure_expected_length = [](const std::vector<std::vector<uint8_t>>& data, size_t expected_length) -> bool {
                    if (data.size() != expected_length) {
                      ESP_LOGW("ExtendedImprov", "Received data with invalid length: expected %d, got %d", expected_length, data.size());
                      set_error_notify_and_clear(improv::Error::ERROR_INVALID_RPC);
                      return false;
                    }
                    return true;
                  };
                  id(last_ble_communication_timestamp) = millis();
                  if (x.empty()) return;
                  improv_buffer.insert(improv_buffer.end(), x.begin(), x.end());
                  ESP_LOGD("ExtendedImprov", "Characteristic received: %s from %d", format_hex_pretty(std::string(improv_buffer.begin(), improv_buffer.end()).c_str()).c_str(), id);
                  uint8_t length = improv_buffer[1];
                  if (improv_buffer.size() - 3 == length) {
                    id(improv_error_characteristic)->set_value(improv::Error::ERROR_NONE);
                    id(improv_error_characteristic)->notify();
                    improv::ImprovCommand command = improv::parse_improv_data(improv_buffer);
                    switch (command.command) {
                      case improv::BAD_CHECKSUM:
                        ESP_LOGW("ExtendedImprov", "Error decoding Improv payload");
                        set_error_notify_and_clear(improv::Error::ERROR_INVALID_RPC);
                        break;
                      case improv::WIFI_SETTINGS: {
                        ESP_LOGD("ExtendedImprov", "WiFi settings received");
                        if (id(improv_state) == improv::State::STATE_PROVISIONING) {
                          ESP_LOGD("ExtendedImprov", "Settings received, but already provisioning");
                          set_error_notify_and_clear(improv::Error::ERROR_NOT_AUTHORIZED);
                          break;
                        }
                        if (!ensure_expected_length(command.data, 2)) break;
                        id(improv_state) = improv::State::STATE_PROVISIONING;
                        id(improv_status_characteristic)->notify();
                        id(improv_wifi_configure)->execute(std::string(command.data[0].begin(), command.data[0].end()), std::string(command.data[1].begin(), command.data[1].end()));
                        improv_buffer.clear();
                        break;
                      }
                      case improv::CUSTOM: {
                        ESP_LOGD("ExtendedImprov", "Custom command received");
                        switch(command.data[0][0]) {
                          case ${E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID}:
                            if (id(improv_state) == improv::State::STATE_PROVISIONING) {
                              ESP_LOGD("ExtendedImprov", "MQTT settings received, but not authorized");
                              set_error_notify_and_clear(improv::Error::ERROR_NOT_AUTHORIZED);
                              break;
                            }
                            if (!ensure_expected_length(command.data, 6)) break;
                            ESP_LOGD("ExtendedImprov", "MQTT settings received");
                            id(improv_state) = improv::State::STATE_PROVISIONING;
                            id(improv_status_characteristic)->notify();
                            id(improv_mqtt_configure)->execute(std::string(command.data[1].begin(), command.data[1].end()), bytebuffer::ByteBuffer::wrap(command.data[2]).get_uint16(), std::string(command.data[3].begin(), command.data[3].end()), std::string(command.data[4].begin(), command.data[4].end()), command.data[5][0] != 0);
                            break;
                          case ${E_IMPROV_FACTORY_RESET_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Factory reset received");
                            id(factory_reset_button).press();
                            break;
                          case ${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of MQTT settings received");
                            id(improv_wifi_mqtt_show_config)->execute();
                            break;
                          case ${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of WiFi settings received");
                            id(improv_wifi_ble_show_config)->execute();
                            break;
                          case ${E_IMPROV_ENABLE_DIAGNOSTIC_COMMAND_ID}: {
                            ESP_LOGD("ExtendedImprov", "Enable diagnostic command received");
                            if (!ensure_expected_length(command.data, 2)) break;
                            bool enable_diagnostic = command.data[1][0] != 0;
                            if (enable_diagnostic) {
                              id(diagnostic_mode) = true;
                              id(mqtt_initial_connection_setup) = true;
                            } else {
                              id(diagnostic_mode) = false;
                            }
                            id(main_script)->execute();
                            break;
                          }
                          case ${E_IMPROV_MQTT_DISCOVERY_PREFIX_COMMAND_ID}: {
                            ESP_LOGD("ExtendedImprov", "MQTT discovery prefix command received");
                            if (!ensure_expected_length(command.data, 2)) break;
                            std::string new_prefix(command.data[1].begin(), command.data[1].end());
                            id(mqtt_discovery_prefix) = new_prefix;
                            id(mqtt_initial_connection_setup) = true;
                            id(main_script)->execute();
                            break;
                          }
                          default:
                            ESP_LOGW("ExtendedImprov", "Unknown Improv custom payload");
                            break;
                        }
                        improv_buffer.clear();
                        break;
                      }
                      case improv::IDENTIFY:
                        improv_buffer.clear();
                        ESP_LOGW("ExtendedImprov", "IDENTIFY not supported in this device");
                        break;
                      default:
                        ESP_LOGW("ExtendedImprov", "Unknown Improv payload");
                        set_error_notify_and_clear(improv::Error::ERROR_UNKNOWN_RPC);
                    }
                  } else if (improv_buffer.size() - 2 > length) {
                    ESP_LOGD("ExtendedImprov", "Too much data received or data malformed; resetting buffer...");
                    improv_buffer.clear();
                  } else {
                    ESP_LOGD("ExtendedImprov", "Waiting for split data packets...");
                  }
        - uuid: ${IMPROV_CAPABILITIES_UUID}
          read: true
          value:
            data: 0x00
            type: uint8_t
        - uuid: ${IMPROV_RPC_RESULT_UUID}
          id: improv_rpc_result
          read: true
          notify: true

script:
  - id: enable_ble
    then:
      - ble.enable:
      - wait_until:
          ble.enabled

  - id: serve_ble_server
    mode: restart
    then:
      - lambda: |-
          id(improv_state) = improv::State::STATE_AUTHORIZED;
          // Reset last BLE communication timestamp
          id(last_ble_communication_timestamp) = millis();
          // Display BLE status on LED
          auto call = id(led_status)->turn_on();
          call.set_effect("ble_status_effect");
          call.perform();
          // Turn on BLE
          id(enable_ble)->execute();
      - script.wait: enable_ble
      # If the last communication was more than 5 minutes ago, close the server
      - wait_until:
          lambda: ! return millis() - id(last_ble_communication_timestamp) >= ${DELAY_BLE_SERVER_CLOSE_MS};
      # No need to turn off the LED here since it could override other status effects
      # Additionally, if the server is closed due to inactivity (and everything is all-right)
      # the device will turn off inmediately after, so it would be pointless to turn off the LED just before that

  - id: improv_wifi_configure
    parameters:
      ssid: std::string
      password: std::string
    then:
      - lambda: |-
          id(device_setup_state) = ${SETUP_STATE_WIFI_CONFIG};
          id(temp_wifi_ssid) = ssid;
          id(temp_wifi_password) = password;
          id(on_wifi_disconnect)->stop();
          id(on_mqtt_disconnect)->stop();
          auto call = id(led_status)->turn_off();
          call.perform();
      - wifi.configure:
          ssid: !lambda return ssid;
          password: !lambda return password;
          save: true
          timeout: 30s
          on_connect:
            - lambda: |-
                id(wifi_ssid) = id(temp_wifi_ssid);
                id(wifi_password) = id(temp_wifi_password);
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_state) = improv::State::STATE_PROVISIONED;
                id(improv_status_characteristic)->notify();
                id(main_script)->execute();
          on_error:
            - lambda: |-
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_error_characteristic)->set_value(improv::Error::ERROR_UNABLE_TO_CONNECT);
                id(improv_error_characteristic)->notify();
                id(improv_state) = improv::State::STATE_AUTHORIZED;
                id(improv_status_characteristic)->notify();
                id(on_wifi_disconnect)->execute();

  - id: improv_mqtt_configure
    parameters:
      new_mqtt_broker_address: std::string
      new_mqtt_broker_port: uint16_t
      new_mqtt_username: std::string
      new_mqtt_password: std::string
      use_tls: bool
    then:
      - lambda: |-
          id(device_setup_state) = ${SETUP_STATE_MQTT_CONFIG};
          id(on_mqtt_disconnect)->stop();
          id(mqtt_setup)->stop();
          auto call = id(led_status)->turn_off();
          call.perform();
          id(mqtt_id)->disable();
      - wait_until:
        - not: mqtt.connected
      - delay: 5s
      - lambda: |-
          ESP_LOGD("MQTT Config", "Applying new MQTT settings: broker=%s, port=%d, username=%s, use_tls=%s", new_mqtt_broker_address.c_str(), new_mqtt_broker_port, new_mqtt_username.c_str(), use_tls ? "true" : "false");
          // Store new settings in temporary variables while we test the connection
          id(mqtt_setup)->execute(new_mqtt_broker_address, new_mqtt_broker_port, new_mqtt_username, new_mqtt_password, use_tls);
      - script.wait: mqtt_setup
      - lambda: |-
          if (id(mqtt_id)->is_connected()) {
            ESP_LOGD("MQTT Config", "Successfully connected with new MQTT settings");
            id(mqtt_initial_connection_setup) = true;
            id(improv_state) = improv::State::STATE_PROVISIONED;
            // Update MQTT settings since they are correct
            id(mqtt_broker_address) = new_mqtt_broker_address;
            id(mqtt_broker_port) = new_mqtt_broker_port;
            id(mqtt_username) = new_mqtt_username;
            id(mqtt_password) = new_mqtt_password;
          } else {
            ESP_LOGE("MQTT Config", "Failed to connect with new MQTT settings");
            // Notify the client about the failure
            id(improv_error_characteristic)->set_value(improv::Error::ERROR_UNABLE_TO_CONNECT);
            id(improv_error_characteristic)->notify();
            id(improv_state) = improv::State::STATE_AUTHORIZED;
            // Reset MQTT settings to previous values
            id(mqtt_id)->disable();
          }
          id(device_setup_state) = ${SETUP_STATE_INIT};
          id(improv_status_characteristic)->notify();
          id(main_script)->execute();

  - id: improv_wifi_mqtt_show_config
    then:
      - lambda: |-
          std::string mqtt_port_str(sizeof(uint16_t), 0);
          mqtt_port_str[0] = static_cast<char>(id(mqtt_broker_port) & 0xFF);
          mqtt_port_str[1] = static_cast<char>((id(mqtt_broker_port) >> 8) & 0xFF);
          uint8_t tls_flags = id(mqtt_use_tls) ? 1 : 0;
          std::vector<std::string> response = {
              {${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}},                                    
              id(mqtt_broker_address),
              mqtt_port_str,
              std::to_string(tls_flags),
              id(mqtt_username),
              id(mqtt_discovery_prefix)
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();

  - id: improv_wifi_ble_show_config
    then:
      - lambda: |-
          std::string ssid = id(wificomponent)->get_sta().get_ssid();
          std::vector<std::string> response = {
              {${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}},                                    
              ssid
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();
