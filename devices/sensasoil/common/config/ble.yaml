substitutions:
  # Improv BLE
  IMPROV_SERVICE_UUID: "00467768-6228-2272-4663-277478268000"
  IMPROV_STATUS_UUID: "00467768-6228-2272-4663-277478268001"
  IMPROV_ERROR_UUID: "00467768-6228-2272-4663-277478268002"
  IMPROV_RPC_COMMAND_UUID: "00467768-6228-2272-4663-277478268003"
  IMPROV_RPC_RESULT_UUID: "00467768-6228-2272-4663-277478268004"
  IMPROV_CAPABILITIES_UUID: "00467768-6228-2272-4663-277478268005"
  # ExtendedImprov commands
  E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID: "1"
  E_IMPROV_FACTORY_RESET_COMMAND_ID: "2"
  E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID: "3"
  E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID: "4"
  # Custom BLE
  CUSTOM_BLE_SERVICE_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80000"
  CUSTOM_BLE_INFO_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80001"
  # Internal setup states
  SETUP_STATE_INIT: "0"
  SETUP_STATE_WIFI_CONFIG: "1"
  SETUP_STATE_MQTT_CONFIG: "2"
  # Timeouts
  DELAY_BLE_SERVER_CLOSE_MS: "5 * 60 * 1000"

globals:
  # INTERNAL #
  - id: last_ble_communication_timestamp
    type: unsigned long
    restore_value: no
    initial_value: "0"
  - id: improv_buffer
    type: std::vector<uint8_t>
    restore_value: no
  - id: improv_state
    type: uint8_t
    restore_value: no
  - id: device_setup_state
    type: uint8_t
    restore_value: no
    initial_value: ${SETUP_STATE_INIT}

esp32_ble:
  id: ble_id
  enable_on_boot: False

esp32_ble_server:
  id: ble_server
  manufacturer: TierraLive
  model: SensaSoil_${HARDWARE_VERSION}
  # TODO: Maximum one client
  on_connect:
    - lambda: |-
        // Refresh sensors on BLE connection to have updated values
        id(refresh_sensors_script)->execute();
        id(last_ble_communication_timestamp) = millis();
  services:
    - uuid: 0x180F
      advertise: false
      characteristics: 
        - uuid: 0x2A19
          id: ble_battery_level_char
          read: true
          notify: true
          value: !lambda |-
            return { static_cast<uint8_t>(std::round(id(battery_percentage).state)) };
        - uuid: 0x2BED
          id: ble_battery_status_char
          read: true
          notify: true
          value: !lambda |-
            // Flags field (8 bits)
            uint8_t flags = 0b00000010;
            // Power state field (16 bits)
            uint16_t power_state = 0b0000000000000000;
            // Battery present (bit 0)
            // Assume always 1 (we cannot check that)
            power_state |= 0b0000000000000001;
            // Wired external power source connected (bits 1-2)
            // Set to 10 (unknown) as we do not know if it is connected to a charger
            power_state |= (0b10 << 1);
            // Wireless external power source connected (bits 3-4)
            power_state |= (0b10 << 3);
            // Set to 10 (unknown) as we do not know if it is solar charging
            // Battery charge state (bits 5-6)
            if (id(is_battery_charging).state) {
              // Charging
              power_state |= (0b01 << 5);
            } else {
              // Discharging
              power_state |= (0b10 << 5);
            }
            // Battery charge level (bits 7-8)
            float bat_level = id(battery_percentage).state;
            if (bat_level <= 5.0) {
              // Critical
              power_state |= (0b11 << 7);
            } else if (bat_level <= 20.0) {
              // Low
              power_state |= (0b10 << 7);
            } else {
              // Good
              power_state |= (0b01 << 7);
            }
            // Display battery level too
            uint8_t battery_level_output = static_cast<uint8_t>(std::round(bat_level));
            return { flags, static_cast<uint8_t>(power_state & 0xFF), static_cast<uint8_t>((power_state >> 8) & 0xFF), battery_level_output };
    - uuid: ${CUSTOM_BLE_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${CUSTOM_BLE_INFO_UUID}
          read: true
          value: !lambda |-
            uint8_t mac[6];
            get_mac_address_raw(mac);
            return std::vector<uint8_t>(std::begin(mac), std::end(mac));
    - uuid: ${IMPROV_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${IMPROV_STATUS_UUID}
          id: improv_status_characteristic
          read: true
          notify: true
          value: !lambda return {id(improv_state)};
        - uuid: ${IMPROV_ERROR_UUID}
          id: improv_error_characteristic
          read: true
          notify: true
        - uuid: ${IMPROV_RPC_COMMAND_UUID}
          write: true
          on_write:
            then:
              # TODO: Add "INDENTIFY" capabilities
              - lambda: |-
                  ESP_LOGD("ExtendedImprov", "Characteristic received: %s from %d", std::string(x.begin(), x.end()).c_str(), id);
                  id(last_ble_communication_timestamp) = millis();
                  if (x.empty()) return;
                  id(improv_buffer).insert(id(improv_buffer).end(), x.begin(), x.end());
                  uint8_t length = id(improv_buffer)[1];
                  if (id(improv_buffer).size() - 3 == length) {
                    id(improv_error_characteristic)->set_value(improv::ERROR_NONE);
                    id(improv_error_characteristic)->notify();
                    improv::ImprovCommand command = improv::parse_improv_data(id(improv_buffer));
                    switch (command.command) {
                      case improv::BAD_CHECKSUM:
                        ESP_LOGW("ExtendedImprov", "Error decoding Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_INVALID_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                        break;
                      case improv::WIFI_SETTINGS: {
                        ESP_LOGD("ExtendedImprov", "Wi-Fi settings received");
                        if (id(improv_state) != improv::STATE_AUTHORIZED) {
                          ESP_LOGD("CustomImprov", "Settings received, but not authorized");
                          id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                          id(improv_error_characteristic)->notify();
                          id(improv_buffer).clear();
                          return;
                        }
                        id(improv_state) = improv::STATE_PROVISIONING;
                        id(improv_status_characteristic)->notify();
                        id(improv_wifi_configure)->execute(std::string(command.data[0].begin(), command.data[0].end()), std::string(command.data[1].begin(), command.data[1].end()));
                        id(improv_buffer).clear();
                        break;
                      }
                      case improv::CUSTOM: {
                        ESP_LOGD("ExtendedImprov", "Custom command received");
                        switch(command.data[0][0]) {
                          case ${E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID}:
                            if (id(improv_state) != improv::STATE_AUTHORIZED) {
                              ESP_LOGD("CustomImprov", "MQTT settings received, but not authorized");
                              id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                              id(improv_error_characteristic)->notify();
                              id(improv_buffer).clear();
                              return;
                            }
                            ESP_LOGD("ExtendedImprov", "MQTT settings received");
                            id(improv_state) = improv::STATE_PROVISIONING;
                            id(improv_status_characteristic)->notify();
                            id(improv_mqtt_configure)->execute(std::string(command.data[1].begin(), command.data[1].end()), bytebuffer::ByteBuffer::wrap(command.data[2]).get_uint16(), std::string(command.data[3].begin(), command.data[3].end()), std::string(command.data[4].begin(), command.data[4].end()));
                            break;
                          case ${E_IMPROV_FACTORY_RESET_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Factory reset received");
                            id(factory_reset_button).press();
                          case ${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of MQTT settings received");
                            id(improv_wifi_mqtt_show_config)->execute();
                            break;
                          case ${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of WiFi settings received");
                            id(improv_wifi_ble_show_config)->execute();
                            break;
                          default:
                            ESP_LOGW("ExtendedImprov", "Unknown Improv custom payload");
                            break;
                        }
                        break;
                      }
                      case improv::IDENTIFY:
                        id(improv_buffer).clear();
                        ESP_LOGW("ExtendedImprov", "IDENTIFY");
                        break;
                      default:
                        ESP_LOGW("ExtendedImprov", "Unknown Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_UNKNOWN_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                    }
                  } else if (id(improv_buffer).size() - 2 > length) {
                    ESP_LOGD("ExtendedImprov", "Too much data received or data malformed; resetting buffer...");
                    id(improv_buffer).clear();
                  } else {
                    ESP_LOGD("ExtendedImprov", "Waiting for split data packets...");
                  }
        - uuid: ${IMPROV_CAPABILITIES_UUID}
          read: true
          value:
            data: 0x00
            type: uint8_t
        - uuid: ${IMPROV_RPC_RESULT_UUID}
          id: improv_rpc_result
          read: true
          notify: true

script:
  - id: execute_ble_server
    mode: restart
    then:
      # Turn on BLE
      - lambda: |-
          id(improv_state) = improv::STATE_AUTHORIZED;
          id(ble_id)->enable();
          // Reset last BLE communication timestamp
          id(last_ble_communication_timestamp) = millis();
      - wait_until:
          ble.enabled
      # Display LED status
      - light.turn_on:
          id: led_status
          effect: "ble_status_effect"
      # If the last communication was more than 5 minutes ago, close the server
      - wait_until:
          lambda: ! return millis() - id(last_ble_communication_timestamp) >= ${DELAY_BLE_SERVER_CLOSE_MS};
      - light.turn_off: led_status

  - id: improv_wifi_configure
    parameters:
      ssid: std::string
      password: std::string
    then:
      - lambda: ! id(device_setup_state) = ${SETUP_STATE_WIFI_CONFIG};
      - wifi.configure:
          ssid: !lambda return ssid;
          password: !lambda return password;
          save: true
          timeout: 30000ms
          on_connect:
            - lambda: |-
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_state) = improv::STATE_PROVISIONED;
                id(improv_status_characteristic)->notify();
          on_error:
            - lambda: |-
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_error_characteristic)->set_value(improv::ERROR_UNABLE_TO_CONNECT);
                id(improv_error_characteristic)->notify();
                id(improv_state) = improv::ERROR_UNABLE_TO_CONNECT;
                id(improv_status_characteristic)->notify();

  - id: improv_mqtt_configure
    parameters:
      new_mqtt_broker_address: std::string
      new_mqtt_broker_port: uint16_t
      new_mqtt_username: std::string
      new_mqtt_password: std::string
    then:
      - script.stop: mqtt_setup
      - mqtt.disable
      - wait_until:
        - not: mqtt.connected
      - lambda: |-
          id(mqtt_initial_connection_setup) = true;
          id(device_setup_state) = ${SETUP_STATE_MQTT_CONFIG};
          id(improv_mqtt_configure_error_timeout)->execute(id(mqtt_broker_address), id(mqtt_broker_port), id(mqtt_username), id(mqtt_password));
          id(mqtt_broker_address) = new_mqtt_broker_address;
          id(mqtt_broker_port) = new_mqtt_broker_port;
          id(mqtt_username) = new_mqtt_username;
          id(mqtt_password) = new_mqtt_password;
          id(mqtt_setup)->execute();
      - script.wait: mqtt_setup
      - lambda: |-
          id(improv_mqtt_configure_error_timeout)->stop();
          id(device_setup_state) = ${SETUP_STATE_INIT};
          id(improv_state) = improv::STATE_PROVISIONED;
          id(improv_status_characteristic)->notify();

  - id: improv_mqtt_configure_error_timeout
    parameters:
      old_mqtt_broker_address: std::string
      old_mqtt_broker_port: uint16_t
      old_mqtt_username: std::string
      old_mqtt_password: std::string
    then:
      - delay: 5min
      - lambda: |-
          id(improv_mqtt_configure)->stop();
          id(mqtt_setup)->stop();
          id(device_setup_state) = ${SETUP_STATE_INIT};
          id(improv_error_characteristic)->set_value(improv::ERROR_UNABLE_TO_CONNECT);
          id(improv_error_characteristic)->notify();
          id(improv_state) = improv::ERROR_UNABLE_TO_CONNECT;
          id(improv_status_characteristic)->notify();
          id(mqtt_broker_address) = old_mqtt_broker_address;
          id(mqtt_broker_port) = old_mqtt_broker_port;
          id(mqtt_username) = old_mqtt_username;
          id(mqtt_password) = old_mqtt_password;
          id(mqtt_setup)->execute();

  - id: improv_wifi_mqtt_show_config
    then:
      - lambda: |-
          std::string mqtt_port_str(sizeof(uint16_t), 0);
          mqtt_port_str[0] = static_cast<char>(id(mqtt_broker_port) & 0xFF);
          mqtt_port_str[1] = static_cast<char>((id(mqtt_broker_port) >> 8) & 0xFF);
          std::vector<std::string> response = {
              {${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}},                                    
              id(mqtt_broker_address),
              mqtt_port_str,
              id(mqtt_username)
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();

  - id: improv_wifi_ble_show_config
    then:
      - lambda: |-
          std::string ssid = id(wificomponent)->get_sta().get_ssid();
          std::vector<std::string> response = {
              {${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}},                                    
              ssid
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();
