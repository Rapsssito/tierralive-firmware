.public_sensor: &public_sensor
  update_interval: never
  qos: 1
  subscribe_qos: 1

substitutions:
  # Public connection error states
  SENSASOIL_STATE_ERROR_WIFI: "WIFI"
  SENSASOIL_STATE_ERROR_MQTT: "MQTT"
  SENSASOIL_STATE_ERROR_MQTT_TIMEOUT: "MQTT_TIMEOUT"
  SENSASOIL_STATE_ERROR_OTA: "OTA"
  # Public error states
  SENSASOIL_STATE_ERROR_NONE: "0"
  SENSASOIL_STATE_ERROR_UNKNOWN: "UNKNOWN"
  SENSASOIL_STATE_ERROR_PANIC: "PANIC"
  SENSASOIL_STATE_ERROR_WDT: "WDT"
  SENSASOIL_STATE_ERROR_BROWNOUT: "BROWNOUT"
  SENSASOIL_STATE_ERROR_EFUSE: "EFUSE"
  SENSASOIL_STATE_ERROR_PWR_GLITCH: "PWR_GLITCH"
  SENSASOIL_STATE_ERROR_CPU_LOCKUP: "CPU_LOCKUP"

globals:
  # INTERNAL #
  - id: diagnostic_mode
    type: bool
    restore_value: yes
    initial_value: "false"

sensor:
  - platform: template
    id: network_signal
    name: "Network signal"
    accuracy_decimals: 0
    unit_of_measurement: "dBm"
    state_class: measurement
    entity_category: "diagnostic"
    device_class: SIGNAL_STRENGTH
    state_topic: !lambda 'return id(diagnostic_mode) ? id(mqtt_id).get_topic_prefix() + "/n_s" : "";'
    lambda: |-
        return id(wifi_signal_db).state;
    <<: *public_sensor
  - platform: wifi_signal
    name: "WiFi signal"
    id: wifi_signal_db
    accuracy_decimals: 0
    update_interval: never
    internal: true
  - platform: internal_temperature
    id: chip_temperature
    name: "Chip temperature"
    accuracy_decimals: 1
    device_class: TEMPERATURE
    state_class: measurement
    entity_category: "diagnostic"
    state_topic: !lambda 'return id(diagnostic_mode) ? id(mqtt_id).get_topic_prefix() + "/c_t" : "";'
    <<: *public_sensor
  - platform: template
    id: deep_sleep_duration
    name: "Deep sleep duration"
    entity_category: "diagnostic"
    icon: mdi:clock-outline
    state_class: measurement
    unit_of_measurement: minutes
    lambda: ! return id(battery_level).state;
    filters:
    - calibrate_linear:
        - 0.00 -> 60 # 1h
        - 100.00 -> 15 # 15min
    <<: *public_sensor
    state_topic: !lambda 'return id(diagnostic_mode) ? id(mqtt_id).get_topic_prefix() + "/s_d" : "";'

text_sensor:
  - platform: template
    id: firmware_version
    name: "Firmware version"
    icon: mdi:chip
    entity_category: "diagnostic"
    <<: *public_sensor
    state_topic: !lambda 'return id(mqtt_initial_connection_setup) ? id(mqtt_id).get_topic_prefix() + "/fw" : "";'
  - platform: template
    id: hardware_version
    name: "Hardware version"
    icon: mdi:memory
    entity_category: "diagnostic"
    <<: *public_sensor
    state_topic: !lambda 'return id(mqtt_initial_connection_setup) ? id(mqtt_id).get_topic_prefix() + "/hw" : "";'
  - platform: template
    id: error_state
    name: "Error state"
    icon: mdi:alert-outline
    entity_category: "diagnostic"
    lambda: |-
        switch (esp_reset_reason()) {
        case ESP_RST_PANIC:
        return std::string("${SENSASOIL_STATE_ERROR_PANIC}");
        case ESP_RST_INT_WDT:
        case ESP_RST_TASK_WDT:
        case ESP_RST_WDT:
        return std::string("${SENSASOIL_STATE_ERROR_WDT}");
        case ESP_RST_BROWNOUT:
        return std::string("${SENSASOIL_STATE_ERROR_BROWNOUT}");
        case ESP_RST_EFUSE:
        return std::string("${SENSASOIL_STATE_ERROR_EFUSE}");
        case ESP_RST_PWR_GLITCH:
        return std::string("${SENSASOIL_STATE_ERROR_PWR_GLITCH}");
        case ESP_RST_CPU_LOCKUP:
        return std::string("${SENSASOIL_STATE_ERROR_CPU_LOCKUP}");
        default:
        break;
        }
        switch (id(last_exec_error)) {
        case ${ERROR_WIFI}:
        return std::string("${SENSASOIL_STATE_ERROR_WIFI}");
        case ${ERROR_OTA}:
        return std::string("${SENSASOIL_STATE_ERROR_OTA}");
        case ${ERROR_MQTT}:
        return std::string("${SENSASOIL_STATE_ERROR_MQTT}");
        case ${ERROR_MQTT_TIMEOUT}:
        return std::string("${SENSASOIL_STATE_ERROR_MQTT_TIMEOUT}");
        case ${ERROR_NONE}:
        return std::string("${SENSASOIL_STATE_ERROR_NONE}");
        default:
        return std::string("${SENSASOIL_STATE_ERROR_UNKNOWN}");
        }
    <<: *public_sensor
    state_topic: !lambda return id(mqtt_id).get_topic_prefix() + "/er";

light:
  - platform: monochromatic
    id: led_status
    name: "Status LED"
    output: led_status_output_internal  # Must be defined by the device configuration
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          # Blink 2.5 times every second
          name: "wifi_disconnect_effect"
          transition_length: 200ms
          update_interval: 200ms
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          # Blink quickly every second
          name: "mqtt_disconnect_effect"
          transition_length:
            on_length: 200ms
            off_length: 1ms
          update_interval: 2s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          # Pulse slowly every 4 seconds
          name: "ble_status_effect"
          transition_length: 2s
          update_interval: 2s
          min_brightness: 40%
          max_brightness: 100%
    internal: True
