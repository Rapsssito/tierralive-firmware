substitutions:
  MQTT_PREFIX: "ss"
  MQTT_DEFAULT_ADDRESS: "192.168.1.68"
  MQTT_DEFAULT_PORT: "1883"
  # Internal error codes
  ERROR_NONE: "0"
  ERROR_WIFI: "1"
  ERROR_MQTT: "2"
  ERROR_MQTT_TIMEOUT: "3"
  ERROR_OTA: "4"
  # Error timeouts
  DELAY_ERROR_WIFI_MS: "2 * 60 * 1000"
  DELAY_ERROR_MQTT_MS: "2 * 60 * 1000"
  SLEEP_ERROR_WIFI_MS: "5 * 60 * 1000"
  SLEEP_ERROR_MQTT_MS: "5 * 60 * 1000"
  # Constants
  INITIAL_UPDATE_ID: "1"
  INITIAL_RECEIVED_UPDATE_ID: "0"

globals:
  # CONFIGURABLE BY THE USER #
  - id: mqtt_broker_address
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"${MQTT_DEFAULT_ADDRESS}"'
  - id: mqtt_broker_port
    type: uint16_t
    restore_value: yes
    initial_value: ${MQTT_DEFAULT_PORT}
  - id: mqtt_username
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '""'
  - id: mqtt_password
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '""'
  - id: wifi_ssid
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '""'
  - id: wifi_password
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '""'
  # INTERNAL #
  - id: ota_url
    type: std::string
    restore_value: no
  - id: mqtt_initial_connection_setup
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: mqtt_data_persisted
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_exec_error
    type: uint8_t
    restore_value: yes
    initial_value: ${ERROR_NONE}
  - id: received_update_id
    type: std::string
    restore_value: no
    initial_value: '"${INITIAL_RECEIVED_UPDATE_ID}"'
  - id: current_update_id
    type: std::string
    restore_value: no
    initial_value: '"${INITIAL_UPDATE_ID}"'

mqtt:
  # TODO: Check if possible clear HA topics after OTA
  # TODO: Use SSL/TLS
  id: mqtt_id
  broker: "127.0.0.1"  # Configured by globals
  username: "u"  # Configured by globals
  password: "p"  # Configured by globals
  idf_send_async: true
  keepalive: 5min
  # TODO: Enable again when ESPHome supports it
  # clean_session: RTC
  enable_on_boot: False
  discover_ip: False
  discovery_unique_id_generator: mac
  on_disconnect:
    - script.execute: on_mqtt_disconnect
  # This makes Home Assistant always show a status (instead of "unavailable")
  birth_message:
  will_message:
  # No need for shutdown message
  shutdown_message:
  # No need for MQTT logs
  log_topic: null

wifi:
  id: wificomponent
  enable_on_boot: false
  ssid: "s"  # Configured by globals
  password: "pppppppp"  # Configured by globals
  fast_connect: True
  on_disconnect:
    - script.execute: on_wifi_disconnect

script:
  - id: on_wifi_disconnect
    then:
      - lambda: |-
          // Skip disconnect script if configuring WiFi
          if (id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG}) {
            id(on_wifi_disconnect)->stop();
            return;
          }
          ESP_LOGE("on_wifi_disconnect", "WiFi disconnected");
          // Stop main script to avoid conflicts with the disconnect scripts
          id(main_script)->stop();
          // This has priority over MQTT disconnect, so stop it to avoid conflicts
          id(on_mqtt_disconnect)->stop();
          if (id(manual_reset)) {
            // Display led status only if the device is being handled
            // else it would be just uselessly blinking
            auto call = id(led_status)->turn_on();
            call.set_effect("wifi_disconnect_effect");
            call.perform();
          } else {
            // Start error sleep timeout if the error comes after a sleep
            id(send_to_deep_sleep)->execute(${DELAY_ERROR_WIFI_MS}, ${SLEEP_ERROR_WIFI_MS});
          }
          id(last_exec_error) = ${ERROR_WIFI};
      # Wait for WiFi to be connected
      - wait_until:
          wifi.connected
      # Housekeeping
      - lambda: |-
          id(send_to_deep_sleep)->stop();
          auto call = id(led_status)->turn_off();
          call.perform();
          id(main_script)->execute();

  - id: on_mqtt_disconnect
    then:
      - lambda: |-
          // Skip disconnect script if configuring MQTT or on_wifi_disconnect is running
          if (id(device_setup_state) == ${SETUP_STATE_MQTT_CONFIG} || id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG} || id(on_wifi_disconnect)->is_running()) {
            id(on_mqtt_disconnect)->stop();
            return;
          }
          ESP_LOGE("on_mqtt_disconnect", "MQTT disconnected");
          // Stop main script to avoid conflicts with the disconnect scripts
          id(main_script)->stop();
          if (id(manual_reset)) {
            // Display led status only if the device is being handled
            // else it would be just uselessly blinking
            auto call = id(led_status)->turn_on();
            call.set_effect("mqtt_disconnect_effect");
            call.perform();
          } else {
            // Start error sleep timeout if the error comes after a sleep
            id(send_to_deep_sleep)->execute(${DELAY_ERROR_MQTT_MS}, ${SLEEP_ERROR_MQTT_MS});
          }
          id(last_exec_error) = ${ERROR_MQTT};
      # Wait for MQTT to be connected
      - wait_until:
          mqtt.connected
      # Housekeeping
      - lambda: |-
          id(send_to_deep_sleep)->stop();
          auto call = id(led_status)->turn_off();
          call.perform();
          id(main_script)->execute();

  - id: network_setup
    then:
      # TODO: When modem, include modem setup
      - script.execute: wifi_setup
      - script.wait: wifi_setup

  - id: wifi_setup
    then:
      - lambda: |-
          // If no SSID is configured, directly show the WiFi error
          if (id(wifi_ssid) == "") {
            id(on_wifi_disconnect)->execute();
            id(wifi_setup)->stop();
            return;
          }
          // Setup WiFi connection manually based on the stored SSID
          wifi::WiFiAP wifi_wifiap_id = wifi::WiFiAP();
          wifi_wifiap_id.set_ssid(id(wifi_ssid));
          wifi_wifiap_id.set_password(id(wifi_password));
          wifi_wifiap_id.set_priority(0);
          id(wificomponent)->set_sta(wifi_wifiap_id);
          id(wificomponent)->enable();
      - wait_until:
          condition:
            - wifi.connected
          timeout: 30s
      - lambda: |-
          if(id(wificomponent)->is_connected()) {
            return;
          }
          id(on_wifi_disconnect)->execute();

  - id: mqtt_setup
    parameters:
      mqtt_broker_address: std::string
      mqtt_broker_port: uint16_t
      mqtt_username: std::string
      mqtt_password: std::string
    then:
      # Setup MQTT connection
      - lambda: |-
          // If no broker address is configured, directly show the MQTT error
          if (mqtt_username == "") {
            id(mqtt_setup)->stop();
            id(on_mqtt_disconnect)->execute();
            return;
          }
          uint8_t mac[6];
          get_mac_address_raw(mac);
          std::string mac_base64 = base64_encode(mac, 6);
          // Convert to base64URL
          for (char &c : mac_base64) {
              if (c == '+') c = '-';
              else if (c == '/') c = '_';
          }
          // TODO: Add option to set the topic prefix
          id(mqtt_id).set_topic_prefix("${MQTT_PREFIX}/" + mac_base64, "");
          id(mqtt_id).set_broker_address(mqtt_broker_address);
          id(mqtt_id).set_broker_port(mqtt_broker_port);
          id(mqtt_id).set_username(mqtt_username);
          id(mqtt_id).set_password(mqtt_password);
          id(mqtt_id).set_client_id(mac_base64);
          if (!id(mqtt_initial_connection_setup)) { id(mqtt_id).disable_discovery(); }
          // These subscriptions are here so there is no need to re-subscribe if the session persisted to save bandwidth
          // Add subscription for last message id
          id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/id", [=](const std::string &topic, const std::string &payload) {
                // This is the initial message received after boot, we can use it to check if the data was persisted in the broker
                if (id(current_update_id) == "${INITIAL_UPDATE_ID}") {
                  id(mqtt_data_persisted) = true;
                  return;
                }
                id(received_update_id) = payload;
            }, 1);
          id(mqtt_id)->enable();
      - wait_until:
          condition:
            - mqtt.connected
          timeout: 30s
      - lambda: |-
          if(id(mqtt_id)->is_connected()) {
            return;
          }
          id(on_mqtt_disconnect)->execute();

  - id: perform_initial_connection
    then:
      # Wait a bit to make sure the retained message is received
      - wait_until:
          condition:
            - lambda: ! return id(mqtt_data_persisted);
          timeout: 5s
      - lambda: |-
          // If the data is not persisted, we need to do the initial connection setup
          if (!id(mqtt_data_persisted)) {
            id(mqtt_initial_connection_setup) = true;
          }

  - id: deep_sleep_wait_mqtt
    then:
        # Publish manually the id
        - lambda: |-
            std::string payload = std::to_string(esp_random());
            id(current_update_id) = payload;
            id(mqtt_id)->publish(id(mqtt_id).get_topic_prefix() + "/id", payload, 1, true);
        # Listen to the final state being published
        - wait_until:
            condition:
              - lambda: ! return id(current_update_id) == id(received_update_id);
            timeout: 1min
        - lambda: |-
            if(id(current_update_id) == id(received_update_id)) {
              // Everything went fine, go to deep sleep
              id(send_to_deep_sleep)->execute(100, id(deep_sleep_duration).state * 1000 * 60);
            } else {
              ESP_LOGE("deep_sleep_wait_mqtt", "MQTT timeout waiting for update ID to be received. current_update_id: %s, received_update_id: %s", id(current_update_id).c_str(), id(received_update_id).c_str());
              id(last_exec_error) = ${ERROR_MQTT_TIMEOUT};
              // If the message is not received in time, reset with a short deep sleep to avoid blocking the device if something is wrong with the MQTT connection
              id(send_to_deep_sleep)->execute(100, 5 * 60 * 1000);
            }
            // As a well behaved device, disconnect from MQTT broker to avoid wasting resources on the broker side while sleeping
            id(mqtt_id)->disable();
