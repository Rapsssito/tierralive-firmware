substitutions:
  MQTT_PREFIX: "ss"
  MQTT_DEFAULT_ADDRESS: "192.168.1.68"
  MQTT_DEFAULT_PORT: "1883"
  # Internal error codes
  ERROR_NONE: "0"
  ERROR_WIFI: "1"
  ERROR_MQTT: "2"
  ERROR_MQTT_TIMEOUT: "3"

globals:
  # CONFIGURABLE BY THE USER #
  - id: mqtt_broker_address
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"${MQTT_DEFAULT_ADDRESS}"'
  - id: mqtt_broker_port
    type: uint16_t
    restore_value: yes
    initial_value: ${MQTT_DEFAULT_PORT}
  - id: mqtt_username
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  - id: mqtt_password
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  # INTERNAL #
  - id: ota_url
    type: std::string
    restore_value: no
  - id: mqtt_initial_connection_setup
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: mqtt_data_persisted
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_exec_error
    type: uint8_t
    restore_value: yes
    initial_value: ${ERROR_NONE}
  - id: received_last_update_id
    type: std::string
    restore_value: no
    initial_value: '"1"'

mqtt:
  id: mqtt_id
  broker: "127.0.0.1"  # Configured by globals
  username: "u"  # Configured by globals
  password: "p"  # Configured by globals
  keepalive: 5min
  # TODO: Enable again when ESPHome supports it
  # clean_session: RTC
  enable_on_boot: False
  discover_ip: False
  discovery_unique_id_generator: mac
  on_disconnect:
    - script.execute: on_mqtt_disconnect
  # This makes Home Assistant always show a status (instead of "unavailable")
  birth_message:
  will_message:
  # No need for shutdown message
  shutdown_message:
  # No need for MQTT logs
  log_topic: null

# TODO: change to enable_on_boot false
wifi:
  id: wificomponent
  ssid: "ssid"
  password: "password"
  fast_connect: True

script:
  - id: on_wifi_disconnect
    then:
      # Skip disconnect script if configuring the Wi-Fi
      - if:
          condition:
            - lambda: ! return id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG};
          then:
            - script.stop: on_wifi_disconnect
      - script.stop: execute_ble_server
      - script.stop: on_mqtt_disconnect
      # Open BLE connection for setup
      - ble.enable
      - wait_until:
          ble.enabled
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "wifi_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - if:
          condition:
            - lambda: ! return esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER;
          then:
            - script.execute:
                id: send_to_deep_sleep
                delay_ms: 1 * 60 * 1000
                sleep_duration_ms: 5 * 60 * 1000
      - lambda: ! id(last_exec_error) = ${ERROR_WIFI};
      # Wait for WiFi to be connected
      - wait_until:
          wifi.connected
      # Housekeeping
      - script.stop: send_to_deep_sleep
      - light.turn_off: led_status
      # Call main execution
      - script.execute: main_script

  - id: on_mqtt_disconnect
    # TODO: Improve this to not restart everything when BLE is active
    # TODO: Do not start BLE, it will waste energy, same for WiFi
    then:
      # Skip disconnect script if configuring the MQTT
      - if:
          condition:
            - lambda: ! return id(device_setup_state) == ${SETUP_STATE_MQTT_CONFIG} || id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG};
          then:
            - script.stop: on_mqtt_disconnect
      - script.wait: on_wifi_disconnect
      - script.stop: execute_ble_server
      # Open BLE connection for setup
      - ble.enable
      - wait_until:
          ble.enabled
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "mqtt_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - if:
          condition:
            - lambda: ! return esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER;
          then:
            - script.execute:
                id: send_to_deep_sleep
                delay_ms: 1 * 60 * 1000
                sleep_duration_ms: 5 * 60 * 1000
      - lambda: ! id(last_exec_error) = ${ERROR_MQTT};
      # Wait for MQTT to be connected
      - wait_until:
          mqtt.connected
      # Housekeeping
      - script.stop: send_to_deep_sleep
      - light.turn_off: led_status
      # Call main execution
      - script.execute: main_script

  - id: mqtt_setup
    then:
      # Setup MQTT connection
      - lambda: |-
          uint8_t mac[6];
          get_mac_address_raw(mac);
          std::string mac_base64 = base64_encode(mac, 6);
          // Convert to base64URL
          for (char &c : mac_base64) {
              if (c == '+') c = '-';
              else if (c == '/') c = '_';
          }
          id(mqtt_id).set_topic_prefix("${MQTT_PREFIX}/" + mac_base64, "");
          id(mqtt_id).set_broker_address(id(mqtt_broker_address));
          id(mqtt_id).set_broker_port(id(mqtt_broker_port));
          id(mqtt_id).set_username(id(mqtt_username));
          id(mqtt_id).set_password(id(mqtt_password));
          if (!id(mqtt_initial_connection_setup)) { id(mqtt_id).disable_discovery(); }
      # These subscriptions are here so they have priority over all other subscriptions
      # Add subscription for last message id
      - lambda: |-
          id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/id", [=](const std::string &topic, const std::string &payload) {
                id(received_last_update_id) = payload;
            }, 1);
      # Check if the data was already persisted in the broker
      - lambda: |-
          id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/i", [=](const std::string &topic, const std::string &payload) {
              id(mqtt_data_persisted) = payload == "1";
          }, 1);
      - mqtt.enable
      - wait_until: mqtt.connected

  - id: check_initial_connection
    then:
      # Wait a bit to make sure the retained message is received
      - wait_until:
          condition:
            - lambda: ! return id(mqtt_data_persisted);
          timeout: 1s
      - if:
          condition:
            - lambda: ! return !id(mqtt_data_persisted);
          then:
            - mqtt.publish:
                topic: !lambda return id(mqtt_id).get_topic_prefix() + "/i";
                qos: 1
                payload: "1"
                retain: true
            # If the data was not persisted, mark that the initial connection setup is required
            - if:
                condition:
                  - lambda: ! return !id(mqtt_initial_connection_setup);
                then:
                  - lambda: ! id(mqtt_initial_connection_setup) = true;
                  # Soft reset to send the necessary discovery and diagnostic messages
                  - script.execute:
                      id: send_to_deep_sleep
                      delay_ms: 0
                      sleep_duration_ms: 100

  - id: deep_sleep_wait_mqtt
    then:
        # Update last update timestamp
        - text_sensor.template.publish:
            id: last_update_id
            state: !lambda return std::to_string(esp_random());
        # Listen to the final state being published
        - wait_until:
            condition:
              - lambda: ! return id(last_update_id).state == id(received_last_update_id);
            timeout: 1min
        - if:
            condition:
              - lambda: ! return id(last_update_id).state == id(received_last_update_id);
            then:
              # Everything went fine, go to deep sleep
              - script.execute:
                  id: send_to_deep_sleep
                  delay_ms: 0
                  sleep_duration_ms: !lambda return id(deep_sleep_duration).state * 1000 * 60;
            else:
              - lambda: ! id(last_exec_error) = ${ERROR_MQTT_TIMEOUT};
              # If the message is not received in time, reset
              - script.execute:
                  id: send_to_deep_sleep
                  delay_ms: 0
                  sleep_duration_ms: 5 * 60 * 1000
              - script.wait: send_to_deep_sleep
