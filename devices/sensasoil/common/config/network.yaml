substitutions:
  MQTT_PREFIX: "ss"
  MQTT_DEFAULT_ADDRESS: "192.168.1.68"
  MQTT_DEFAULT_PORT: "1883"
  # Internal error codes
  ERROR_NONE: "0"
  ERROR_WIFI: "1"
  ERROR_MQTT: "2"
  ERROR_MQTT_TIMEOUT: "3"
  # Error timeouts
  DELAY_ERROR_WIFI_MS: "2 * 60 * 1000"
  DELAY_ERROR_MQTT_MS: "2 * 60 * 1000"
  SLEEP_ERROR_WIFI_MS: "5 * 60 * 1000"
  SLEEP_ERROR_MQTT_MS: "5 * 60 * 1000"

globals:
  # CONFIGURABLE BY THE USER #
  - id: mqtt_broker_address
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"${MQTT_DEFAULT_ADDRESS}"'
  - id: mqtt_broker_port
    type: uint16_t
    restore_value: yes
    initial_value: ${MQTT_DEFAULT_PORT}
  - id: mqtt_username
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  - id: mqtt_password
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  # INTERNAL #
  - id: ota_url
    type: std::string
    restore_value: no
  - id: mqtt_initial_connection_setup
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: mqtt_data_persisted
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_exec_error
    type: uint8_t
    restore_value: yes
    initial_value: ${ERROR_NONE}
  - id: received_last_update_id
    type: std::string
    restore_value: no
    initial_value: '"1"'

mqtt:
  id: mqtt_id
  broker: "127.0.0.1"  # Configured by globals
  username: "u"  # Configured by globals
  password: "p"  # Configured by globals
  keepalive: 5min
  # TODO: Enable again when ESPHome supports it
  # clean_session: RTC
  enable_on_boot: False
  discover_ip: False
  discovery_unique_id_generator: mac
  on_disconnect:
    - script.execute: on_mqtt_disconnect
  # This makes Home Assistant always show a status (instead of "unavailable")
  birth_message:
  will_message:
  # No need for shutdown message
  shutdown_message:
  # No need for MQTT logs
  log_topic: null

wifi:
  id: wificomponent
  enable_on_boot: false
  ssid: "ssid"
  password: "password"
  fast_connect: True
  on_disconnect:
    - script.execute: on_wifi_disconnect

script:
  - id: on_wifi_disconnect
    then:
      - lambda: |-
          // Skip disconnect script if configuring WiFi
          if (id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG}) {
            id(on_wifi_disconnect)->stop();
            return;
          }
          ESP_LOGE("on_wifi_disconnect", "WiFi disconnected");
          // Stop start script to avoid conflicts with the disconnect scripts
          id(start_script)->stop();
          // This has priority over MQTT disconnect, so stop it to avoid conflicts
          id(on_mqtt_disconnect)->stop();
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "wifi_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - lambda: |-
          if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER) {
            id(send_to_deep_sleep)->execute(${DELAY_ERROR_WIFI_MS}, ${SLEEP_ERROR_WIFI_MS});
          }
          id(last_exec_error) = ${ERROR_WIFI};
      # Wait for WiFi to be connected
      - wait_until:
          wifi.connected
      # Housekeeping
      - script.stop: send_to_deep_sleep
      - light.turn_off: led_status
      # Restart main execution
      - script.execute: start_script

  - id: on_mqtt_disconnect
    then:
      - lambda: |-
          // Skip disconnect script if configuring MQTT
          if (id(device_setup_state) == ${SETUP_STATE_MQTT_CONFIG} || id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG}) {
            id(on_mqtt_disconnect)->stop();
            return;
          }
          ESP_LOGE("on_mqtt_disconnect", "MQTT disconnected");
          // Stop start script to avoid conflicts with the disconnect scripts
          id(start_script)->stop();
      - script.wait: on_wifi_disconnect
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "mqtt_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - lambda: |-
          if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER) {
            id(send_to_deep_sleep)->execute(${DELAY_ERROR_MQTT_MS}, ${SLEEP_ERROR_MQTT_MS});
          }
          id(last_exec_error) = ${ERROR_MQTT};
      # Wait for MQTT to be connected
      - wait_until:
          mqtt.connected
      # Housekeeping
      - script.stop: send_to_deep_sleep
      - light.turn_off: led_status
      # Restart main execution
      - script.execute: start_script

  - id: network_setup
    then:
      # TODO: When modem, include modem setup
      - lambda: |-
          id(wificomponent)->enable();
      - wait_until:
          condition:
            - wifi.connected
          timeout: 30s
      - lambda: |-
          if(id(wificomponent)->is_connected()) {
            return;
          }
          id(on_wifi_disconnect)->execute();

  - id: mqtt_setup
    then:
      # Setup MQTT connection
      - lambda: |-
          uint8_t mac[6];
          get_mac_address_raw(mac);
          std::string mac_base64 = base64_encode(mac, 6);
          // Convert to base64URL
          for (char &c : mac_base64) {
              if (c == '+') c = '-';
              else if (c == '/') c = '_';
          }
          id(mqtt_id).set_topic_prefix("${MQTT_PREFIX}/" + mac_base64, "");
          id(mqtt_id).set_broker_address(id(mqtt_broker_address));
          id(mqtt_id).set_broker_port(id(mqtt_broker_port));
          id(mqtt_id).set_username(id(mqtt_username));
          id(mqtt_id).set_password(id(mqtt_password));
          if (!id(mqtt_initial_connection_setup)) { id(mqtt_id).disable_discovery(); }
          // These subscriptions are here so they have priority over all other subscriptions
          // Add subscription for last message id
          id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/id", [=](const std::string &topic, const std::string &payload) {
                id(received_last_update_id) = payload;
            }, 1);
          // Check if the data was already persisted in the broker
          id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/i", [=](const std::string &topic, const std::string &payload) {
              id(mqtt_data_persisted) = payload == "1";
          }, 1);
          id(mqtt_id)->enable();
      - wait_until: mqtt.connected

  - id: perform_initial_connection
    then:
      # Wait a bit to make sure the retained message is received
      - wait_until:
          condition:
            - lambda: ! return id(mqtt_data_persisted);
          timeout: 1s
      - lambda: |-
          if (id(mqtt_data_persisted)) {
            return;
          }
          id(mqtt_id)->publish(id(mqtt_id).get_topic_prefix() + "/i", "1", 1, 1, true);
          // If the data is not persisted, we need to do the initial connection setup
          if (!id(mqtt_initial_connection_setup)) {
            id(mqtt_initial_connection_setup) = true;
            // Soft reset to send the necessary discovery and diagnostic messages
            id(send_to_deep_sleep)->execute(0, 100);
          }

  - id: deep_sleep_wait_mqtt
    then:
        # Update last update timestamp
        - text_sensor.template.publish:
            id: last_update_id
            state: !lambda return std::to_string(esp_random());
        # Listen to the final state being published
        - wait_until:
            condition:
              - lambda: ! return id(last_update_id).state == id(received_last_update_id);
            timeout: 1min
        - lambda: |-
            if(id(last_update_id).state == id(received_last_update_id)) {
              // Everything went fine, go to deep sleep
              id(send_to_deep_sleep)->execute(0, id(deep_sleep_duration).state * 1000 * 60);
            } else {
              id(last_exec_error) = ${ERROR_MQTT_TIMEOUT};
              // If the message is not received in time, reset with a short deep sleep to avoid blocking the device if something is wrong with the MQTT connection
              id(send_to_deep_sleep)->execute(0, 5 * 60 * 1000);
            }
