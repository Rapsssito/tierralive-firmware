substitutions:
  # ESPHome minimum version (kept in sync with esphome.version)
  ESPHOME_MIN_VERSION: !include ../../../../esphome.version

globals:
  - id: factory_clean
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: manual_reset
    type: bool
    restore_value: no
    initial_value: "false"

esphome:
  name: "sensasoil-v${HARDWARE_VERSION_FLAT}"
  friendly_name: "SensaSoil v${HARDWARE_VERSION}"
  name_add_mac_suffix: true
  min_version: "${ESPHOME_MIN_VERSION}"
  project: 
    name: "tierralive.sensasoil"
    version: "${FIRMWARE_VERSION}"
  includes:
    - "<improv.h>"
  libraries:
    - improv=https://github.com/rapsssito/extended-improv-sdk-cpp
  on_boot:
    - priority: -100
      then:
        - lambda: |-
            id(manual_reset) = esp_reset_reason() == ESP_RST_UNKNOWN || esp_reset_reason() == ESP_RST_POWERON || esp_reset_reason() == ESP_RST_EXT || esp_reset_reason() == ESP_RST_USB || esp_reset_reason() == ESP_RST_JTAG;
            id(manual_reset) = id(manual_reset) || id(factory_clean);
            id(factory_clean) = false;
        - script.execute: main_script

mdns:
  disabled: true

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  flash_size: "4MB"
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y

script:
  - id: main_script
    mode: restart
    then:
      # Start BLE server if waked up by power on
      - lambda: |-
          if (id(manual_reset)) {
            id(enable_ble)->execute();
            id(serve_ble_server)->execute();
          }
      # Wait for the BLE server to be ready in case we need it for setup
      # This won't block if we don't need the BLE server or if it's already ready
      - script.wait: enable_ble
      # Network
      - script.execute: network_setup
      # If network fails, this script will be stopped by the disconnect scripts
      - script.wait: network_setup
      # OTA
      - script.execute: check_ota
      # If OTA fails, this script will continue to MQTT setup since we assume the network is working
      - script.wait: check_ota
      # MQTT
      - script.execute:
          id: mqtt_setup
          mqtt_broker_address: !lambda return id(mqtt_broker_address);
          mqtt_broker_port: !lambda return id(mqtt_broker_port);
          mqtt_username: !lambda return id(mqtt_username);
          mqtt_password: !lambda return id(mqtt_password);
          use_tls: !lambda return id(mqtt_use_tls);
      # If mqtt fails, this script will be stopped by the disconnect scripts
      - script.wait: mqtt_setup
      # Check if we need to do the initial connection setup (only if the data is not persisted)
      - script.execute: perform_initial_connection
      - script.wait: perform_initial_connection
      # Sensors
      - script.execute: refresh_sensors_script
      - script.wait: refresh_sensors_script
      # Wait in case the BLE server is still running
      - script.wait: serve_ble_server
      - lambda: |-
          ESP_LOGI("main_script", "Main script complete, entering deep sleep");
          id(last_exec_error) = ${ERROR_NONE};
          id(mqtt_initial_connection_setup) = false;
          id(deep_sleep_wait_mqtt)->execute();
