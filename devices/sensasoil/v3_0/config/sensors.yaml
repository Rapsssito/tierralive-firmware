.public_sensor: &public_sensor
  update_interval: never
  qos: 1
  subscribe_qos: 1

substitutions:
  # Public device states
  SENSASOIL_STATE_DEEP_SLEEP: "0"
  SENSASOIL_STATE_TX_DATA: "1"
  SENSASOIL_STATE_BLE_SERVER: "2"
  # Public connection error states
  SENSASOIL_STATE_ERROR_WIFI: "111"
  SENSASOIL_STATE_ERROR_MQTT: "112"
  # Public error states
  SENSASOIL_STATE_ERROR_PANIC: "123"
  SENSASOIL_STATE_ERROR_WDT: "124"
  SENSASOIL_STATE_ERROR_BROWNOUT: "125"
  SENSASOIL_STATE_ERROR_EFUSE: "126"
  SENSASOIL_STATE_ERROR_PWR_GLITCH: "127"
  SENSASOIL_STATE_ERROR_CPU_LOCKUP: "128"

sensor:
  - platform: wifi_signal
    name: "WiFi signal"
    id: wifi_signal_db
    <<: *public_sensor
    state_class: measurement
    entity_category: "diagnostic"
    device_class: signal_strength
  - platform: internal_temperature
    id: chip_temperature
    name: "Chip temperature"
    device_class: TEMPERATURE
    state_class: measurement
    entity_category: "diagnostic"
    <<: *public_sensor
  - platform: dht
    pin: GPIO5
    model: DHT22
    id: temperature_humidity_sensor
    update_interval: never
    temperature:
      name: "Ambient temperature"
      id: ambient_temperature
      state_class: measurement
      device_class: TEMPERATURE
      qos: 1
      subscribe_qos: 1
    humidity:
      name: "Ambient humidity"
      id: ambient_humidity
      device_class: HUMIDITY
      state_class: measurement
      qos: 1
      subscribe_qos: 1
  - platform: adc
    id: battery_v
    pin: GPIO3
    name: "Battery voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    samples: 20
    filters:
    - calibrate_linear:
          - 1.91 -> 3.3
          - 2.40 -> 4.2
    state_class: measurement
    <<: *public_sensor
  - platform: template
    id: battery_percentage
    name: "Battery percentage"
    unit_of_measurement: "%"
    state_class: measurement
    device_class: BATTERY
    icon: mdi:battery
    lambda: ! return id(battery_v).state;
    filters:
    - calibrate_linear:
        - 3.3 -> 0.00
        - 4.2 -> 100.00
    - clamp:
        min_value: 0
        max_value: 100
    on_value:
      then:
        - if:
            condition:
              - ble.enabled
            then:
              - ble_server.characteristic.notify:
                  id: ble_battery_level_char
              - ble_server.characteristic.notify:
                  id: ble_battery_status_char
    <<: *public_sensor
  - platform: adc
    id: soil_temperature_v
    pin: GPIO1
    name: "Soil temperature voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    samples: 20
    state_class: measurement
    <<: *public_sensor
  - platform: template
    id: soil_temperature
    name: "Soil temperature"
    icon: mdi:thermometer-probe
    unit_of_measurement: "Â°C"
    device_class: TEMPERATURE
    state_class: measurement
    lambda: ! return id(soil_temperature_v).state;
    filters:
    - lambda: return 298.15 / (1 + 298.15 / 4050 * log(3.3 / x - 1)) - 273.15;
    <<: *public_sensor
  - platform: adc
    id: soil_volumetric_water_v
    pin: GPIO4
    name: "Soil volumetric water voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    samples: 20
    state_class: measurement
    <<: *public_sensor
  - platform: template
    id: soil_volumetric_water
    name: "Soil volumetric water"
    icon: mdi:water-percent
    unit_of_measurement: "%"
    device_class: MOISTURE
    state_class: measurement
    lambda: ! return id(soil_volumetric_water_v).state;
    filters:
    - lambda: return 778 * exp(-2.51 * x);
    - clamp:
        min_value: 0
        max_value: 100
    <<: *public_sensor
  - platform: template
    id: deep_sleep_duration
    name: "Deep sleep duration"
    entity_category: "diagnostic"
    icon: mdi:clock-outline
    state_class: measurement
    unit_of_measurement: minutes
    lambda: ! return id(battery_percentage).state;
    filters:
    - calibrate_linear:
        - 0.00 -> 60 # 1h
        - 100.00 -> 15 # 15min
    <<: *public_sensor
  - platform: template
    id: current_state
    name: "Current state"
    icon: mdi:state-machine
    entity_category: "diagnostic"
    accuracy_decimals: 0
    <<: *public_sensor

script:
  - id: refresh_sensors_script
    then:
      # Turn on peripheral power if not already
      - if:
          condition:
            switch.is_off: power_peripherals
          then:
            - switch.turn_on: power_peripherals
      # Publish state for firmware and hardware versions only once
      - if:
          condition:
            lambda: ! return id(mqtt_initial_connection);
          then:
            - text_sensor.template.publish:
                id: firmware_version
                state: "${FIRMWARE_VERSION}"
            - text_sensor.template.publish:
                id: hardware_version
                state: "${HARDWARE_VERSION}"
      # Publish state of non-peripherals
      - sensor.template.publish:
          id: current_state
          state: !lambda |-
                switch (esp_reset_reason()) {
                case ESP_RST_PANIC:
                return ${SENSASOIL_STATE_ERROR_PANIC};
                case ESP_RST_INT_WDT:
                case ESP_RST_TASK_WDT:
                case ESP_RST_WDT:
                return ${SENSASOIL_STATE_ERROR_WDT};
                case ESP_RST_BROWNOUT:
                return ${SENSASOIL_STATE_ERROR_BROWNOUT};
                case ESP_RST_EFUSE:
                return ${SENSASOIL_STATE_ERROR_EFUSE};
                case ESP_RST_PWR_GLITCH:
                return ${SENSASOIL_STATE_ERROR_PWR_GLITCH};
                case ESP_RST_CPU_LOCKUP:
                return ${SENSASOIL_STATE_ERROR_CPU_LOCKUP};
                default:
                break;
                }
                switch (id(last_exec_error)) {
                case ${ERROR_WIFI}:
                return ${SENSASOIL_STATE_ERROR_WIFI};
                case ${ERROR_MQTT}:
                return ${SENSASOIL_STATE_ERROR_MQTT};
                default:
                return ${SENSASOIL_STATE_TX_DATA};
                }
      - binary_sensor.template.publish:
          id: is_battery_charging
          state: !lambda return id(is_charging_internal).state;
      - component.update: chip_temperature
      - delay: 1ms
      - component.update: wifi_signal_db
      - component.update: battery_v
      - delay: 1ms
      - component.update: battery_percentage
      # Update time to sleep based on battery level
      - component.update: deep_sleep_duration
      # Wait 150ms since power_peripherals_time
      - if:
          condition:
            lambda: !lambda return 150 > (millis() - id(power_peripherals_time));
          then:
            - delay: !lambda return 150 - (millis() - id(power_peripherals_time));
      # Update peripherals voltage sensors
      - component.update: soil_temperature_v
      - delay: 1ms
      - component.update: temperature_humidity_sensor
      - delay: 1ms
      - component.update: soil_volumetric_water_v
      - delay: 1ms
      # Turn off peripheral power
      - switch.turn_off: power_peripherals
      # Update template sensors based on the voltage
      - component.update: soil_volumetric_water
      - component.update: soil_temperature
      # Update last update timestamp
      - text_sensor.template.publish:
          id: last_update_id
          state: !lambda return std::to_string(millis());
