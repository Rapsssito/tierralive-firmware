logger:
  level: DEBUG

esphome:
  name: tierralive-sensasoil-debug
  friendly_name: SensaSoil DEBUG
  # name_add_mac_suffix: true
  platformio_options:
    board_build.flash_mode: dio # Required for ESP32-C3
  min_version: '2025.8.0'
  project: 
    name: "tierralive.sensasoil"
    version: "${FIRMWARE_VERSION}"
  includes:
    - "<improv.h>"
  libraries:
    - improv=https://github.com/rapsssito/extended-improv-sdk-cpp
  on_boot:
    - priority: 260
      then:
        # Wait 30s for WiFi connection
        - delay: 30s
        - if:
            condition:
              - not:
                - wifi.connected:
            then:
              - script.execute: on_wifi_disconnect
    - priority: 190
      then:
        - script.execute: mqtt_setup
    - priority: -100
      then:
        - script.wait: mqtt_setup
        - script.execute: main_script

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  flash_size: "4MB"
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y

substitutions:
  # MQTT prefix
  MQTT_PREFIX: "ss"
  MQTT_DEFAULT_ADDRESS: "192.168.1.68"
  MQTT_DEFAULT_PORT: "1883"
  # Versions for OTA
  FIRMWARE_VERSION: "1.0.3"
  HARDWARE_VERSION: "3.0"
  # Public device states
  SENSASOIL_STATE_DEEP_SLEEP: "0"
  SENSASOIL_STATE_TX_DATA: "1"
  SENSASOIL_STATE_BLE_SERVER: "2"
  # Public connection error states
  SENSASOIL_STATE_ERROR_WIFI: "111"
  SENSASOIL_STATE_ERROR_MQTT: "112"
  # Public error states
  SENSASOIL_STATE_ERROR_PANIC: "123"
  SENSASOIL_STATE_ERROR_WDT: "124"
  SENSASOIL_STATE_ERROR_BROWNOUT: "125"
  SENSASOIL_STATE_ERROR_EFUSE: "126"
  SENSASOIL_STATE_ERROR_PWR_GLITCH: "127"
  SENSASOIL_STATE_ERROR_CPU_LOCKUP: "128"
  # Improv BLE
  IMPROV_SERVICE_UUID: "00467768-6228-2272-4663-277478268000"
  IMPROV_STATUS_UUID: "00467768-6228-2272-4663-277478268001"
  IMPROV_ERROR_UUID: "00467768-6228-2272-4663-277478268002"
  IMPROV_RPC_COMMAND_UUID: "00467768-6228-2272-4663-277478268003"
  IMPROV_RPC_RESULT_UUID: "00467768-6228-2272-4663-277478268004"
  IMPROV_CAPABILITIES_UUID: "00467768-6228-2272-4663-277478268005"
  # ExtendedImprov commands
  E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID: "1"
  E_IMPROV_FACTORY_RESET_COMMAND_ID: "2"
  E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID: "3"
  E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID: "4"
  # Custom BLE
  CUSTOM_BLE_SERVICE_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80000"
  CUSTOM_BLE_INFO_UUID: "3b351f04-1db6-49f3-b155-cb5d18c80001"
  # Internal setup states
  SETUP_STATE_INIT: "0"
  SETUP_STATE_WIFI_CONFIG: "1"
  SETUP_STATE_MQTT_CONFIG: "2"
  # Internal error codes
  ERROR_NO: "0"
  ERROR_WIFI: "1"
  ERROR_MQTT: "2"

deep_sleep:
  id: deep_sleep_1

mqtt:
  id: mqtt_id
  broker: "127.0.0.1"  # Configured by globals
  username: "u"  # Configured by globals
  password: "p"  # Configured by globals
  keepalive: 5min
  # clean_session: RTC
  enable_on_boot: False
  discover_ip: False
  discovery_unique_id_generator: mac
  on_disconnect:
    - script.execute: on_mqtt_disconnect
  # This makes Home Assistant always show a status (instead of "unavailable")
  birth_message:
  will_message:
  # No need for shutdown message
  shutdown_message:
  # No need for MQTT logs
  log_topic: null

http_request:
  useragent: SensaSoil_${HARDWARE_VERSION}/${FIRMWARE_VERSION}

ota:
  - platform: esphome
    password: "e35c052131kbccczbdd6e25434016cda1f"
  - platform: http_request
    on_end:
      - lambda: ! id(mqtt_discovery_required) = true;
    on_error:
      - switch.turn_off: prevent_deep_sleep
      - script.execute: main_script


wifi:
  id: wificomponent
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True

esp32_ble:
  id: ble_id
  enable_on_boot: False

esp32_ble_server:
  id: ble_server
  manufacturer: TierraLive
  model: SensaSoil_${HARDWARE_VERSION}
  # TODO: Maximum one client
  on_connect:
    # Update sensors
    - script.execute: refresh_sensors_script
    - lambda: |-
        ESP_LOGD("BLE", "Connection from %d", id);
    - lambda: ! id(last_ble_communication_timestamp) = millis();
  on_disconnect:
    - lambda: |-
        ESP_LOGD("BLE", "Disconnection from %d", id);
  services:
    - uuid: 0x180F
      advertise: false
      characteristics: 
        - uuid: 0x2A19
          id: ble_battery_level_char
          read: true
          notify: true
          value: !lambda |-
            return { static_cast<uint8_t>(std::round(id(battery_percentage).state)) };
        - uuid: 0x2BED
          id: ble_battery_status_char
          read: true
          notify: true
          value: !lambda |-
            // Flags field (8 bits)
            uint8_t flags = 0b00000010;
            // Power state field (16 bits)
            uint16_t power_state = 0b0000000000000000;
            // Battery present (bit 0)
            // Assume always 1 (we cannot check that)
            power_state |= 0b0000000000000001;
            // Wired external power source connected (bits 1-2)
            // Set to 10 (unknown) as we do not know if it is connected to a charger
            power_state |= (0b10 << 1);
            // Wireless external power source connected (bits 3-4)
            power_state |= (0b10 << 3);
            // Set to 10 (unknown) as we do not know if it is solar charging
            // Battery charge state (bits 5-6)
            if (id(is_battery_charging).state) {
              // Charging
              power_state |= (0b01 << 5);
            } else {
              // Discharging
              power_state |= (0b10 << 5);
            }
            // Battery charge level (bits 7-8)
            float bat_level = id(battery_percentage).state;
            if (bat_level <= 5.0) {
              // Critical
              power_state |= (0b11 << 7);
            } else if (bat_level <= 20.0) {
              // Low
              power_state |= (0b10 << 7);
            } else {
              // Good
              power_state |= (0b01 << 7);
            }
            // Display battery level too
            uint8_t battery_level_output = static_cast<uint8_t>(std::round(bat_level));
            return { flags, static_cast<uint8_t>(power_state & 0xFF), static_cast<uint8_t>((power_state >> 8) & 0xFF), battery_level_output };
    - uuid: ${CUSTOM_BLE_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${CUSTOM_BLE_INFO_UUID}
          read: true
          value: !lambda |-
            uint8_t mac[6];
            get_mac_address_raw(mac);
            return std::vector<uint8_t>(std::begin(mac), std::end(mac));
    - uuid: ${IMPROV_SERVICE_UUID}
      advertise: true
      characteristics:
        - uuid: ${IMPROV_STATUS_UUID}
          id: improv_status_characteristic
          read: true
          notify: true
          value: !lambda return {id(improv_state)};
        - uuid: ${IMPROV_ERROR_UUID}
          id: improv_error_characteristic
          read: true
          notify: true
        - uuid: ${IMPROV_RPC_COMMAND_UUID}
          write: true
          on_write:
            then:
              # TODO: Add "INDENTIFY" capabilities
              - lambda: |-
                  ESP_LOGD("ExtendedImprov", "Characteristic received: %s from %d", std::string(x.begin(), x.end()).c_str(), id);
                  id(last_ble_communication_timestamp) = millis();
                  if (x.empty()) return;
                  id(improv_buffer).insert(id(improv_buffer).end(), x.begin(), x.end());
                  uint8_t length = id(improv_buffer)[1];
                  if (id(improv_buffer).size() - 3 == length) {
                    id(improv_error_characteristic)->set_value(improv::ERROR_NONE);
                    id(improv_error_characteristic)->notify();
                    improv::ImprovCommand command = improv::parse_improv_data(id(improv_buffer));
                    switch (command.command) {
                      case improv::BAD_CHECKSUM:
                        ESP_LOGW("ExtendedImprov", "Error decoding Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_INVALID_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                        break;
                      case improv::WIFI_SETTINGS: {
                        ESP_LOGD("ExtendedImprov", "Wi-Fi settings received");
                        if (id(improv_state) != improv::STATE_AUTHORIZED) {
                          ESP_LOGD("CustomImprov", "Settings received, but not authorized");
                          id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                          id(improv_error_characteristic)->notify();
                          id(improv_buffer).clear();
                          return;
                        }
                        id(improv_state) = improv::STATE_PROVISIONING;
                        id(improv_status_characteristic)->notify();
                        id(improv_wifi_configure)->execute(std::string(command.data[0].begin(), command.data[0].end()), std::string(command.data[1].begin(), command.data[1].end()));
                        id(improv_buffer).clear();
                        break;
                      }
                      case improv::CUSTOM: {
                        ESP_LOGD("ExtendedImprov", "Custom command received");
                        switch(command.data[0][0]) {
                          case ${E_IMPROV_MQTT_CHANGE_SETTINGS_COMMAND_ID}:
                            if (id(improv_state) != improv::STATE_AUTHORIZED) {
                              ESP_LOGD("CustomImprov", "MQTT settings received, but not authorized");
                              id(improv_error_characteristic)->set_value(improv::ERROR_NOT_AUTHORIZED);
                              id(improv_error_characteristic)->notify();
                              id(improv_buffer).clear();
                              return;
                            }
                            ESP_LOGD("ExtendedImprov", "MQTT settings received");
                            id(improv_state) = improv::STATE_PROVISIONING;
                            id(improv_status_characteristic)->notify();
                            id(improv_mqtt_configure)->execute(std::string(command.data[1].begin(), command.data[1].end()), bytebuffer::ByteBuffer::wrap(command.data[2]).get_uint16(), std::string(command.data[3].begin(), command.data[3].end()), std::string(command.data[4].begin(), command.data[4].end()));
                            break;
                          case ${E_IMPROV_FACTORY_RESET_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Factory reset received");
                            id(factory_reset_button).press();
                          case ${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of MQTT settings received");
                            id(improv_wifi_mqtt_show_config)->execute();
                            break;
                          case ${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}:
                            ESP_LOGD("ExtendedImprov", "Request of WiFi settings received");
                            id(improv_wifi_ble_show_config)->execute();
                            break;
                          default:
                            ESP_LOGW("ExtendedImprov", "Unknown Improv custom payload");
                            break;
                        }
                        break;
                      }
                      case improv::IDENTIFY:
                        id(improv_buffer).clear();
                        ESP_LOGW("ExtendedImprov", "IDENTIFY");
                        break;
                      default:
                        ESP_LOGW("ExtendedImprov", "Unknown Improv payload");
                        id(improv_error_characteristic)->set_value(improv::ERROR_UNKNOWN_RPC);
                        id(improv_error_characteristic)->notify();
                        id(improv_buffer).clear();
                    }
                  } else if (id(improv_buffer).size() - 2 > length) {
                    ESP_LOGD("ExtendedImprov", "Too much data received or data malformed; resetting buffer...");
                    id(improv_buffer).clear();
                  } else {
                    ESP_LOGD("ExtendedImprov", "Waiting for split data packets...");
                  }
        - uuid: ${IMPROV_CAPABILITIES_UUID}
          read: true
          value:
            data: 0x00
            type: uint8_t
        - uuid: ${IMPROV_RPC_RESULT_UUID}
          id: improv_rpc_result
          read: true
          notify: true


sensor:
  - platform: wifi_signal
    name: "WiFi signal"
    id: wifi_signal_db
    update_interval: never
    qos: 1
    subscribe_qos: 1
    state_class: measurement
    entity_category: "diagnostic"
    device_class: signal_strength
  - platform: internal_temperature
    id: chip_temperature
    name: "Chip temperature"
    update_interval: never
    device_class: TEMPERATURE
    qos: 1
    subscribe_qos: 1
    state_class: measurement
    entity_category: "diagnostic"
  - platform: dht
    pin: GPIO5
    model: DHT22
    id: temperature_humidity_sensor
    update_interval: never
    temperature:
      name: "Ambient temperature"
      id: ambient_temperature
      state_class: measurement
      device_class: TEMPERATURE
      qos: 1
      subscribe_qos: 1
    humidity:
      name: "Ambient humidity"
      id: ambient_humidity
      device_class: HUMIDITY
      state_class: measurement
      qos: 1
      subscribe_qos: 1
  - platform: adc
    id: battery_v
    pin: GPIO3
    name: "Battery voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    update_interval: never
    samples: 20
    filters:
    - calibrate_linear:
          - 1.91 -> 3.3
          - 2.40 -> 4.2
    qos: 1
    subscribe_qos: 1
    state_class: measurement
  - platform: template
    id: battery_percentage
    name: "Battery percentage"
    unit_of_measurement: "%"
    state_class: measurement
    device_class: BATTERY
    icon: mdi:battery
    update_interval: never
    qos: 1
    subscribe_qos: 1
    lambda: ! return id(battery_v).state;
    filters:
    - calibrate_linear:
        - 3.3 -> 0.00
        - 4.2 -> 100.00
    - clamp:
        min_value: 0
        max_value: 100
    on_value:
      then:
        - if:
            condition:
              - ble.enabled
            then:
              - ble_server.characteristic.notify:
                  id: ble_battery_level_char
              - ble_server.characteristic.notify:
                  id: ble_battery_status_char
  - platform: adc
    id: soil_temperature_v
    pin: GPIO1
    name: "Soil temperature voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    update_interval: never
    samples: 20
    qos: 1
    subscribe_qos: 1
    state_class: measurement
  - platform: template
    id: soil_temperature
    name: "Soil temperature"
    icon: mdi:thermometer-probe
    update_interval: never
    qos: 1
    subscribe_qos: 1
    unit_of_measurement: "Â°C"
    device_class: TEMPERATURE
    state_class: measurement
    lambda: ! return id(soil_temperature_v).state;
    filters:
    - lambda: return 298.15 / (1 + 298.15 / 4050 * log(3.3 / x - 1)) - 273.15;
  - platform: adc
    id: soil_volumetric_water_v
    pin: GPIO4
    name: "Soil volumetric water voltage"
    attenuation: 12db
    unit_of_measurement: "V"
    entity_category: "diagnostic"
    update_interval: never
    samples: 20
    qos: 1
    subscribe_qos: 1
    state_class: measurement
  - platform: template
    id: soil_volumetric_water
    name: "Soil volumetric water"
    icon: mdi:water-percent
    update_interval: never
    qos: 1
    subscribe_qos: 1
    unit_of_measurement: "%"
    device_class: MOISTURE
    state_class: measurement
    lambda: ! return id(soil_volumetric_water_v).state;
    filters:
    - lambda: return 778 * exp(-2.51 * x);
    - clamp:
        min_value: 0
        max_value: 100
  - platform: template
    id: deep_sleep_duration
    name: "Deep sleep duration"
    entity_category: "diagnostic"
    icon: mdi:clock-outline
    update_interval: never
    state_class: measurement
    qos: 1
    subscribe_qos: 1
    unit_of_measurement: minutes
    lambda: ! return id(battery_percentage).state;
    filters:
    - calibrate_linear:
        - 0.00 -> 60 # 1h
        - 100.00 -> 15 # 15min
  - platform: template
    id: current_state
    name: "Current state"
    icon: mdi:state-machine
    qos: 1
    subscribe_qos: 1
    update_interval: never
    entity_category: "diagnostic"
    accuracy_decimals: 0
  
text_sensor:
  - platform: template
    id: firmware_version
    name: "Firmware version"
    icon: mdi:chip
    qos: 1
    subscribe_qos: 1
    update_interval: never
    entity_category: "diagnostic"
  - platform: template
    id: hardware_version
    name: "Hardware version"
    icon: mdi:memory
    qos: 1
    subscribe_qos: 1
    update_interval: never
    entity_category: "diagnostic"
  - platform: template
    id: last_update_id
    name: "Last update ID"
    icon: mdi:message-badge
    qos: 1
    subscribe_qos: 1
    update_interval: never
    entity_category: "diagnostic"

output:
  - platform: ledc
    id: led_status_output_internal
    pin: GPIO0

light:
  - platform: monochromatic
    qos: 1
    subscribe_qos: 1
    id: led_status
    name: "Status LED"
    output: led_status_output_internal
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          # Blink 5 times every second
          name: "mqtt_disconnect_effect"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          # Blink once every second
          name: "wifi_disconnect_effect"
          transition_length: 250ms
          update_interval: 1s
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          # Pulse slowly every 4 seconds
          name: "manual_ble_server_effect"
          transition_length: 2s
          update_interval: 2s
          min_brightness: 40%
          max_brightness: 100%

binary_sensor:
  - platform: gpio
    id: is_charging_internal
    use_interrupt: true
    pin:
      number: GPIO6
      mode: 
        input: True
        pullup: True
      inverted: True
    internal: True
  - platform: gpio
    id: factory_reset_internal_button
    use_interrupt: True
    pin:
      number: GPIO9
      mode:
        input: True
        pullup: True
      inverted: True
    internal: True
    filters:
      - delayed_on: 15s
      - delayed_off: 10ms
    on_press:
      then:
        - button.press: factory_reset_button
  - platform: template
    id: is_battery_charging
    name: "Charging"
    device_class: BATTERY_CHARGING
    icon: mdi:battery-charging
    qos: 1
    subscribe_qos: 1
    on_state:
      then:
        - if:
            condition:
              - ble.enabled
            then:
              - ble_server.characteristic.notify:
                  id: ble_battery_status_char

switch:
  - platform: gpio
    id: power_peripherals
    pin: GPIO10
    icon: mdi:electric-switch
    name: "Power peripherals"
    restore_mode: ALWAYS_OFF
    qos: 1
    subscribe_qos: 1
    entity_category: "config"
    on_turn_on:
      then:
        - lambda: ! id(power_peripherals_time) = millis();
  - platform: template
    id: prevent_deep_sleep
    icon: mdi:sleep-off
    name: "Prevent deep sleep"
    optimistic: True
    restore_mode: ALWAYS_OFF
    qos: 1
    subscribe_qos: 1
    entity_category: "config"

button:
  - platform: template
    id: refresh_sensors
    name: "Refresh sensors"
    icon: mdi:refresh
    qos: 1
    subscribe_qos: 1
    on_press:
      - script.execute: refresh_sensors_script
  - platform: template
    id: send_to_sleep
    name: "Send to sleep"
    icon: mdi:sleep
    qos: 1
    subscribe_qos: 1
    on_press:
      - script.execute: safe_send_to_deep_sleep
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory reset"
    qos: 1
    subscribe_qos: 1

globals:
  # CONFIGURABLE BY THE USER #
  - id: mqtt_broker_address
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"${MQTT_DEFAULT_ADDRESS}"'
  - id: mqtt_broker_port
    type: uint16_t
    restore_value: yes
    initial_value: ${MQTT_DEFAULT_PORT}
  - id: mqtt_username
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  - id: mqtt_password
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '"admin"'
  # INTERNAL #
  - id: last_ble_communication_timestamp
    type: unsigned long
    restore_value: no
    initial_value: "0"
  - id: ota_url
    type: std::string
    restore_value: no
  - id: mqtt_initial_connection
    type: bool
    restore_value: no
    initial_value: "false"
  - id: power_peripherals_time
    type: unsigned long
    restore_value: no
    initial_value: "0"
  - id: last_exec_error
    type: uint8_t
    restore_value: yes
    initial_value: ${ERROR_NO}
  - id: improv_buffer
    type: std::vector<uint8_t>
    restore_value: no
  - id: improv_state
    type: uint8_t
    restore_value: no
  - id: device_setup_state
    type: uint8_t
    restore_value: no
    initial_value: ${SETUP_STATE_INIT}
  - id: mqtt_discovery_required
    type: bool
    restore_value: yes
    initial_value: "true"

script:
  - id: main_script
    then:
      - logger.log:
          format: "Main script called with ESP reset reason %d"
          args: ['esp_reset_reason()']
      - script.execute: refresh_sensors_script
      - script.wait: refresh_sensors_script
      - if:
          condition:
            - lambda: ! return esp_reset_reason() == ESP_RST_UNKNOWN || esp_reset_reason() == ESP_RST_POWERON || esp_reset_reason() == ESP_RST_USB || esp_reset_reason() == ESP_RST_JTAG;
          then:
            # Start BLE server if waked up by power on
            - script.execute: execute_ble_server
            - script.wait: execute_ble_server
      - lambda: ! id(last_exec_error) = ${ERROR_NO};
      - script.execute: safe_send_to_deep_sleep

  - id: refresh_sensors_script
    then:
      - logger.log: "Refresh sensor data"
      # Turn on peripheral power if not already
      - if:
          condition:
            switch.is_off: power_peripherals
          then:
            - switch.turn_on: power_peripherals
      # Publish state for firmware and hardware versions only once
      - if:
          condition:
            lambda: ! return id(mqtt_initial_connection);
          then:
            - text_sensor.template.publish:
                id: firmware_version
                state: "${FIRMWARE_VERSION}"
            - text_sensor.template.publish:
                id: hardware_version
                state: "${HARDWARE_VERSION}"
      # Publish state of non-peripherals
      - sensor.template.publish:
          id: current_state
          state: !lambda |-
                switch (esp_reset_reason()) {
                case ESP_RST_PANIC:
                return ${SENSASOIL_STATE_ERROR_PANIC};
                case ESP_RST_INT_WDT:
                case ESP_RST_TASK_WDT:
                case ESP_RST_WDT:
                return ${SENSASOIL_STATE_ERROR_WDT};
                case ESP_RST_BROWNOUT:
                return ${SENSASOIL_STATE_ERROR_BROWNOUT};
                case ESP_RST_EFUSE:
                return ${SENSASOIL_STATE_ERROR_EFUSE};
                case ESP_RST_PWR_GLITCH:
                return ${SENSASOIL_STATE_ERROR_PWR_GLITCH};
                case ESP_RST_CPU_LOCKUP:
                return ${SENSASOIL_STATE_ERROR_CPU_LOCKUP};
                default:
                break;
                }
                switch (id(last_exec_error)) {
                case ${ERROR_WIFI}:
                return ${SENSASOIL_STATE_ERROR_WIFI};
                case ${ERROR_MQTT}:
                return ${SENSASOIL_STATE_ERROR_MQTT};
                default:
                return ${SENSASOIL_STATE_TX_DATA};
                }
      - binary_sensor.template.publish:
          id: is_battery_charging
          state: !lambda return id(is_charging_internal).state;
      - component.update: chip_temperature
      - delay: 1ms
      - component.update: wifi_signal_db
      - component.update: battery_v
      - delay: 1ms
      - component.update: battery_percentage
      # Update time to sleep based on battery level
      - component.update: deep_sleep_duration
      # Wait 150ms since power_peripherals_time
      - if:
          condition:
            lambda: !lambda return 150 > (millis() - id(power_peripherals_time));
          then:
            - delay: !lambda return 150 - (millis() - id(power_peripherals_time));
      # Update peripherals voltage sensors
      - component.update: soil_temperature_v
      - delay: 1ms
      - component.update: temperature_humidity_sensor
      - delay: 1ms
      - component.update: soil_volumetric_water_v
      - delay: 1ms
      # Turn off peripheral power
      - switch.turn_off: power_peripherals
      # Update template sensors based on the voltage
      - component.update: soil_volumetric_water
      - component.update: soil_temperature
      # Update last update timestamp
      - text_sensor.template.publish:
          id: last_update_id
          state: !lambda return std::to_string(millis());


  - id: send_to_deep_sleep_
    then:
      - deep_sleep.enter:
          id: deep_sleep_1
          # sleep_duration: !lambda return id(deep_sleep_duration).state * 1000 * 60;
          sleep_duration: 5s

  - id: safe_send_to_deep_sleep
    then:
      - if:
          condition:
            - switch.is_off: prevent_deep_sleep
          then:
            - logger.log: 'Sending to safe deep sleep'
            # TODO: Change and just wait for the publish callback
            # Listen to the final state being published
            - lambda: |-
                id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/sensor/current_state/state", [=](const std::string &topic, const std::string &payload) {
                    if (payload != "${SENSASOIL_STATE_DEEP_SLEEP}") return;
                    id(send_to_deep_sleep_)->execute();
                }, 1);
            - sensor.template.publish:
                id: current_state
                state: ${SENSASOIL_STATE_DEEP_SLEEP}
            # If the message is not received in time, reset
            - script.execute: send_to_error_deep_sleep_after_timeout
            - script.wait: send_to_error_deep_sleep_after_timeout

  - id: on_wifi_disconnect
    then:
      # Skip disconnect script if configuring the Wi-Fi
      - if:
          condition:
            - lambda: ! return id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG};
          then:
            - script.stop: on_wifi_disconnect
      - logger.log: "Handling Wi-Fi disconnect event"
      - switch.turn_on: prevent_deep_sleep
      - script.stop: execute_ble_server
      - script.stop: on_mqtt_disconnect
      # Open BLE connection for setup
      - ble.enable
      - wait_until:
          ble.enabled
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "wifi_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - if:
          condition:
            - lambda: ! return esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER;
          then:
            - script.execute: send_to_error_deep_sleep_after_timeout
      - switch.turn_off: prevent_deep_sleep
      - lambda: ! id(last_exec_error) = ${ERROR_WIFI};
      # Wait for WiFi to be connected
      - wait_until:
          wifi.connected
      # Housekeeping
      - script.stop: send_to_error_deep_sleep_after_timeout
      - light.turn_off: led_status
      # Call main execution
      - script.execute: main_script

  - id: on_mqtt_disconnect
    # TODO: Do not start BLE, it will waste energy, same for WiFi
    then:
      # Skip disconnect script if configuring the MQTT
      - if:
          condition:
            - lambda: ! return id(device_setup_state) == ${SETUP_STATE_MQTT_CONFIG} || id(device_setup_state) == ${SETUP_STATE_WIFI_CONFIG};
          then:
            - script.stop: on_mqtt_disconnect
      - logger.log: "Handling MQTT disconnect event"
      - switch.turn_on: prevent_deep_sleep
      - script.wait: on_wifi_disconnect
      - script.stop: execute_ble_server
      # Open BLE connection for setup
      - ble.enable
      - wait_until:
          ble.enabled
      # Display LED status
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "mqtt_disconnect_effect"
      # Start error sleep timeout if the error comes after a sleep
      - if:
          condition:
            - lambda: ! return esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_TIMER;
          then:
            - script.execute: send_to_error_deep_sleep_after_timeout
      - switch.turn_off: prevent_deep_sleep
      - lambda: ! id(last_exec_error) = ${ERROR_MQTT};
      # Wait for MQTT to be connected
      - wait_until:
          mqtt.connected
      # Log
      # Housekeeping
      - script.stop: send_to_error_deep_sleep_after_timeout
      - light.turn_off: led_status
      # Call main execution
      - script.execute: main_script

  - id: execute_ble_server
    then:
      - logger.log: "Starting BLE server"
      - lambda: ! id(improv_state) = improv::STATE_AUTHORIZED;
      # Turn on BLE
      - ble.enable
      - wait_until:
          ble.enabled
      # Display LED status
      - sensor.template.publish:
          id: current_state
          state: ${SENSASOIL_STATE_BLE_SERVER}
      - light.turn_on: led_status
      - light.control: 
          id: led_status
          effect: "manual_ble_server_effect"
      # Reset last BLE communication
      - lambda: ! id(last_ble_communication_timestamp) = millis();
      # If the last communication was more than 5 minutes ago, close the server
      - wait_until:
          lambda: ! return millis() - id(last_ble_communication_timestamp) >= 5 * 60 * 1000;
      - light.turn_off: led_status

  - id: send_to_error_deep_sleep_after_timeout
    then:
      # Send to sleep after a delay
      # Used to avoid wasting 15mins trying to connect to MQTT or WiFi
      - delay: 1min
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: 5min

  - id: ota_update
    then:
      - logger.log: "Performing OTA update"
      - switch.turn_on: prevent_deep_sleep
      # Get the OTA URL
      - lambda: |-
            id(mqtt_id).subscribe("${MQTT_PREFIX}/f/u", [=](const std::string &topic, const std::string &payload) {
              id(ota_url) = payload;
            }, 1);
      # Wait until the OTA URL is defined
      - wait_until:
        - lambda: ! return !id(ota_url).empty();
      # Call OTA HTTP update
      - ota.http_request.flash:
          url: !lambda return id(ota_url) + "?h=${HARDWARE_VERSION}&ex=bin";
          md5_url: !lambda return id(ota_url) + "?h=${HARDWARE_VERSION}&ex=md5";

  - id: mqtt_setup
    then:
      - logger.log: "MQTT setup"
      # Setup MQTT connection
      - lambda: |-
          uint8_t mac[6];
          get_mac_address_raw(mac);
          std::string mac_base64 = base64_encode(mac, 6);
          // Convert to base64URL
          for (char &c : mac_base64) {
              if (c == '+') c = '-';
              else if (c == '/') c = '_';
          }
          id(mqtt_id).set_topic_prefix("${MQTT_PREFIX}/" + mac_base64, "");
          id(mqtt_id).set_broker_address(id(mqtt_broker_address));
          id(mqtt_id).set_broker_port(id(mqtt_broker_port));
          id(mqtt_id).set_username(id(mqtt_username));
          id(mqtt_id).set_password(id(mqtt_password));
          if (!id(mqtt_discovery_required)) { id(mqtt_id).disable_discovery(); }
      # These subscriptions are here so they have priority over all other subscriptions
      # Avoid sending discovery messages on every startup if already present
      # TODO: Subscribe before startup, but publish afterwards
      - if:
          condition:
            - lambda: ! return id(mqtt_discovery_required);
          then:
            - mqtt.publish:
                topic: !lambda return id(mqtt_id).get_topic_prefix() + "/d";
                qos: 1
                payload: "1"
                retain: True
            - lambda: |-
                id(mqtt_discovery_required) = false;
                id(mqtt_initial_connection) = true;
          else:
            - lambda: |-
                id(mqtt_discovery_required) = true; // By default discovery is required until a message is received
                id(mqtt_id).subscribe(id(mqtt_id).get_topic_prefix() + "/d", [=](const std::string &topic, const std::string &payload) {
                    id(mqtt_discovery_required) = payload != "1";
                }, 1);
      # Check for OTA
      - lambda: |-
          id(mqtt_id).subscribe("${MQTT_PREFIX}/f/${HARDWARE_VERSION}", [=](const std::string &topic, const std::string &payload) {
              if (payload.compare("${FIRMWARE_VERSION}") != 0) {
                id(ota_update)->execute();
              }
          }, 1);
      - mqtt.enable
      - wait_until: mqtt.connected

  - id: improv_wifi_configure
    parameters:
      ssid: std::string
      password: std::string
    then:
      - lambda: ! id(device_setup_state) = ${SETUP_STATE_WIFI_CONFIG};
      - wifi.configure:
          ssid: !lambda return ssid;
          password: !lambda return password;
          save: true
          timeout: 30000ms
          on_connect:
            - lambda: |-
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_state) = improv::STATE_PROVISIONED;
                id(improv_status_characteristic)->notify();
          on_error:
            - lambda: |-
                id(device_setup_state) = ${SETUP_STATE_INIT};
                id(improv_error_characteristic)->set_value(improv::ERROR_UNABLE_TO_CONNECT);
                id(improv_error_characteristic)->notify();
                id(improv_state) = improv::ERROR_UNABLE_TO_CONNECT;
                id(improv_status_characteristic)->notify();

  - id: improv_mqtt_configure
    parameters:
      new_mqtt_broker_address: std::string
      new_mqtt_broker_port: uint16_t
      new_mqtt_username: std::string
      new_mqtt_password: std::string
    then:
      - script.stop: mqtt_setup
      - mqtt.disable
      - wait_until:
        - not: mqtt.connected
      - lambda: |-
          id(device_setup_state) = ${SETUP_STATE_MQTT_CONFIG};
          id(improv_mqtt_configure_error_timeout)->execute(id(mqtt_broker_address), id(mqtt_broker_port), id(mqtt_username), id(mqtt_password));
          id(mqtt_broker_address) = new_mqtt_broker_address;
          id(mqtt_broker_port) = new_mqtt_broker_port;
          id(mqtt_username) = new_mqtt_username;
          id(mqtt_password) = new_mqtt_password;
      - script.execute: mqtt_setup
      - script.wait: mqtt_setup
      - script.stop: improv_mqtt_configure_error_timeout
      - lambda: |-
          id(device_setup_state) = ${SETUP_STATE_INIT};
          id(improv_state) = improv::STATE_PROVISIONED;
          id(improv_status_characteristic)->notify();

  - id: improv_mqtt_configure_error_timeout
    parameters:
      old_mqtt_broker_address: std::string
      old_mqtt_broker_port: uint16_t
      old_mqtt_username: std::string
      old_mqtt_password: std::string
    then:
      - delay: 5min
      - script.stop: improv_mqtt_configure
      - script.stop: mqtt_setup
      - lambda: |-
          id(device_setup_state) = ${SETUP_STATE_INIT};
          id(improv_error_characteristic)->set_value(improv::ERROR_UNABLE_TO_CONNECT);
          id(improv_error_characteristic)->notify();
          id(improv_state) = improv::ERROR_UNABLE_TO_CONNECT;
          id(improv_status_characteristic)->notify();
          id(mqtt_broker_address) = old_mqtt_broker_address;
          id(mqtt_broker_port) = old_mqtt_broker_port;
          id(mqtt_username) = old_mqtt_username;
          id(mqtt_password) = old_mqtt_password;
      - script.execute: mqtt_setup

  - id: improv_wifi_mqtt_show_config
    then:
      - lambda: |-
          std::string mqtt_port_str(sizeof(uint16_t), 0);
          mqtt_port_str[0] = static_cast<char>(id(mqtt_broker_port) & 0xFF);
          mqtt_port_str[1] = static_cast<char>((id(mqtt_broker_port) >> 8) & 0xFF);
          std::vector<std::string> response = {
              {${E_IMPROV_MQTT_VIEW_SETTINGS_COMMAND_ID}},                                    
              id(mqtt_broker_address),
              mqtt_port_str,
              id(mqtt_username)
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();

  - id: improv_wifi_ble_show_config
    then:
      - lambda: |-
          std::string ssid = id(wificomponent)->get_sta().get_ssid();
          std::vector<std::string> response = {
              {${E_IMPROV_WIFI_VIEW_SETTINGS_COMMAND_ID}},                                    
              ssid
          };
          id(improv_rpc_result)->set_value(improv::build_rpc_response(improv::CUSTOM, response, true));
          id(improv_rpc_result)->notify();
